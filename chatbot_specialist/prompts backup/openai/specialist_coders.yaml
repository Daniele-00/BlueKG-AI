# Specialist coders (OpenAI variant)
---
SALES_CYCLE: |
  You generate Cypher for SALES/REVENUE questions.

  User Question: {question}
  Schema:
  {schema}
  ---
  RULES:
  - Start from customer path: (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)
  - VALUE vs QUANTITY:
    - Value-based (fatturato, valore venduto, ricavi): filter `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0` and aggregate `sum(dr.importo)`.
    - Quantity-based (quantità, pezzi, unità): aggregate `sum(dr.quantita)` and DO NOT filter by `dr.tipoValore` unless explicitly requested.
  - Customers: group by c.name. Companies: group by d.dittaId via (d)<-[:APPARTIENE_A]-(c)
  - String filters: toLower(trim(...))
  - Rankings: ORDER BY metric DESC LIMIT N (only if N is asked). If the question uses "ogni", "tutte", "per ciascuna", DO NOT add LIMIT and return all groups.
  - Date: use doc.dataEmissione.year when needed; for months use doc.dataEmissione.month (1–12)
  - Trend questions ("attualmente", crescita/perdita): restrict to the last two years only using `doc.dataEmissione.year IN [date().year, date().year-1]`.
  - Product filters: ALWAYS join via (dr)-[:RIGUARDA_ARTICOLO]->(a:Articolo) and filter a.descrizione
  - If the question contains "quanti", "numero di", "conta", "unici" → use count(DISTINCT ...), do NOT return lists
  - Avoid unnecessary WITH: if one MATCH + RETURN is enough, do not add a WITH. Use WITH only to pass aggregates/variables to the next stage.

  Examples:
  // Top customer by revenue
  MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)
  WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0
  RETURN c.name AS cliente, sum(dr.importo) AS fatturato
  ORDER BY fatturato DESC
  LIMIT 1

  // Revenue per company
  MATCH (d:Ditta)<-[:APPARTIENE_A]-(c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)
  WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0
  RETURN d.dittaId AS ditta, sum(dr.importo) AS fatturato
  ORDER BY fatturato DESC, d.dittaId ASC

  // Top N products by quantity sold
  MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo)
  RETURN a.descrizione AS prodotto, sum(dr.quantita) AS quantitaTotale
  ORDER BY quantitaTotale DESC
  LIMIT 5

  // Price sold for a specific product
  MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo)
  WHERE toLower(trim(a.descrizione)) = 'gas freon solstice n40 r448a' AND dr.tipoValore='Fatturato' AND dr.importo>0
  RETURN sum(dr.importo) AS totaleVenduto

  // Turnover by month in the current year
  MATCH (:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)
  WHERE dr.tipoValore='Fatturato' AND dr.importo>0 AND doc.dataEmissione.year = date().year
  RETURN doc.dataEmissione.month AS mese, sum(dr.importo) AS fatturatoMensile
  ORDER BY mese

  // Best year per company 
  MATCH (d:Ditta)<-[:APPARTIENE_A]-(:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)
  WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0
  WITH d, doc.dataEmissione.year AS anno, sum(dr.importo) AS fatturatoAnnuale
  ORDER BY d.dittaId, fatturatoAnnuale DESC
  WITH d, collect({{anno: anno, fatturato: fatturatoAnnuale}}) AS fatturatiOrdinati
  RETURN d.dittaId AS ditta, fatturatiOrdinati[0].anno AS annoTop, fatturatiOrdinati[0].fatturato AS fatturatoMassimo
  // Do NOT add LIMIT here: return all companies

  // Company status (loss/growth) — TREND
  MATCH (d:Ditta {{dittaId: 'X'}})<-[:APPARTIENE_A]-(:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)
  WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0 AND doc.dataEmissione.year IN [date().year, date().year - 1] 
  RETURN doc.dataEmissione.year AS anno, sum(dr.importo) AS fatturatoAnnuale 
  ORDER BY anno DESC

  Advanced Example (Negative Patterns):
  - Question: "List 5 customers who have never purchased the product 'EXAMPLE PRODUCT'"
  - Correct Logic: Find the product first, then find all customers, then filter out those who have a path to that product.
    MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'example product'
    WITH a
    MATCH (c:Cliente)
    WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a)
    RETURN c.name AS cliente ORDER BY cliente LIMIT 5  


  // Compare turnover between two specific years
  MATCH (:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)
  WHERE dr.tipoValore='Fatturato' AND dr.importo>0 AND doc.dataEmissione.year IN [2023, 2024]
  RETURN doc.dataEmissione.year AS anno, sum(dr.importo) AS fatturatoTotale
  ORDER BY anno

  // Locality with most customers
  MATCH (c:Cliente)-[:HAS_ADDRESS]->(l:Luogo)
  RETURN l.localita AS localita, count(DISTINCT c) AS numeroClientiUnici
  ORDER BY numeroClientiUnici DESC 
  LIMIT 1

  // Companies that sell product of family X
  MATCH (d:Ditta)<-[:APPARTIENE_A]-(:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)-[:INCLUSA_IN]->(fam:Famiglia)
  WHERE toLower(trim(fam.nome)) = 'x'
  RETURN DISTINCT d.dittaId AS ditta
  ORDER BY ditta

  // Revenue for family X
  MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)-[:INCLUSA_IN]->(fam:Famiglia)
  WHERE toLower(trim(fam.nome)) = 'elettrodomestici' AND dr.tipoValore='Fatturato' AND dr.importo>0
  RETURN sum(dr.importo) AS fatturatoFamiglia

PURCHASE_CYCLE: |
  You generate Cypher for PURCHASES/COST questions.

  User Question: {question}
  Schema:
  {schema}
  ---
  RULES:
  - Start from supplier path: (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)
  - Group suppliers by GruppoFornitore: (gf:GruppoFornitore)<-[:RAGGRUPPATO_SOTTO]-(f:Fornitore)
  - VALUE vs QUANTITY:
    - Value-based (costo, speso, pagato, valore acquistato): aggregate `sum(dr.importo)`; no `tipoValore` filter unless explicitly requested.
    - Quantity-based (quantità acquistata, "più acquistata" in termini di quantità): aggregate `sum(dr.quantita)`; DO NOT add `tipoValore` filters unless explicitly requested.
  - String filters: toLower(trim(...))
  - Avoid re-matching after an aggregation that may multiply rows; prefer single MATCH + RETURN or proper scoping
  - When counting documents across joins, prefer count(DISTINCT doc) to avoid duplication
  - Avoid unnecessary WITH: prefer one-stage MATCH + RETURN if possible; use WITH only when needed.

  Examples:
  // Total bought from supplier X
  MATCH (gf:GruppoFornitore)<-[:RAGGRUPPATO_SOTTO]-(:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)
  WHERE toLower(trim(gf.ragioneSociale)) = 'fornitore esempio spa'
  RETURN sum(dr.importo) AS totaleAcquistato

  // Most purchased family
  MATCH (:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)-[:INCLUSA_IN]->(f:Famiglia)
  RETURN f.nome AS famiglia, sum(dr.quantita) AS quantitaTotale
  ORDER BY quantitaTotale DESC
  LIMIT 1

  // Locality with most suppliers
  MATCH (f:Fornitore)-[:SI_TROVA_A]->(l:Luogo)
  RETURN l.localita AS localita, count(DISTINCT f) AS numeroFornitori
  ORDER BY numeroFornitori DESC
  LIMIT 1

  // Total cost for a specific product 
  MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore)
  WHERE toLower(trim(a.descrizione)) = 'gas freon solstice n40 r448a'
  RETURN sum(dr.importo) AS costoTotaleAcquisto

  // Supplier with most documents
  MATCH (gf:GruppoFornitore)<-[:RAGGRUPPATO_SOTTO]-(:Fornitore)-[:HA_EMESSO]->(doc:Documento)
  RETURN gf.ragioneSociale AS fornitore, count(DISTINCT doc) AS numeroDocumenti
  ORDER BY numeroDocumenti DESC
  LIMIT 1

  // Supplier most active in the last quarter (by value)
  WITH date() - duration({{months: 3}}) AS dataInizio
  MATCH (gf:GruppoFornitore)<-[:RAGGRUPPATO_SOTTO]-(:Fornitore)-[:HA_EMESSO]->(doc:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)
  WHERE doc.dataEmissione >= dataInizio
  RETURN gf.ragioneSociale AS fornitore, sum(dr.importo) AS valoreAcquistato
  ORDER BY valoreAcquistato DESC
  LIMIT 1

  Final Cypher Query:

GENERAL_QUERY: |
  You generate SIMPLE Cypher listings (no aggregations).

  User Question: {question}
  Schema:
  {schema}
  ---
  RULES:
  - List or lookup only; 
  - Use DISTINCT to avoid duplicates
  - String filters with toLower(trim(...))
  - ORDER BY result; LIMIT 20 if large lists, 
  - Use SUM, AVG, COUNT only for explicit counts/averages in question (examples words: "how many", "number of", "average", "media", "count")

  // Products in family 'X'
  MATCH (f:Famiglia)<-[:INCLUSA_IN]-(:Sottofamiglia)<-[:APPARTIENE_A]-(a:Articolo)
  WHERE toLower(trim(f.nome)) = 'X'
  RETURN DISTINCT a.descrizione AS prodotto 
  ORDER BY prodotto

  // Customers in Perugia
  MATCH (c:Cliente)-[:HAS_ADDRESS]->(l:Luogo)
  WHERE toLower(trim(l.localita)) = 'perugia'
  RETURN DISTINCT c.name AS cliente ORDER BY cliente LIMIT 5

  // Information about customer with name 'Y'
  MATCH (c:Cliente {{name: 'Y'}})
  RETURN c.name AS nome, c.accountnumber AS codice

  // List with relationship
  MATCH (d:Ditta {{dittaId: '3'}})<-[:APPARTIENE_A]-(c:Cliente)
  RETURN c.name AS cliente
  ORDER BY cliente

  Final Cypher Query:

DITTE_QUERY: |
  You generate Cypher focused on company (ditta) structure, listings, and basic counts (non-monetary).

  User Question: {question}
  Schema:
  {schema}
  ---
  RULES:
  - Always anchor on (d:Ditta) and traverse via Cliente/Fornitore only for structural info (no sums of importi)
  - For counts ("quanti", "numero di", "conta") use count(DISTINCT ...)
  - For listings, use DISTINCT + ORDER BY + LIMIT 20 when list is large
  - Do NOT perform sales/purchase aggregations here (no sum(dr.importo)); if monetario richiesto, route to SALES_CYCLE or PURCHASE_CYCLE
  - String filters: toLower(trim(...))

  Examples:
  // Unique customers of company X
  MATCH (d:Ditta {{dittaId: 'X'}})<-[:APPARTIENE_A]-(c:Cliente)
  RETURN count(DISTINCT c) AS numeroClientiUnici

  // List companies (ditte)
  MATCH (d:Ditta)
  RETURN d.dittaId AS ditta
  ORDER BY ditta
 
  // Sort companies by number of sales documents
  MATCH (d:Ditta)<-[:APPARTIENE_A]-(:Cliente)-[:HA_RICEVUTO]->(doc:Documento)
  RETURN d.dittaId AS ditta, count(doc) AS numeroDocumenti
  ORDER BY numeroDocumenti DESC

  // Companies that sell family Y (structure level, no totals)
  MATCH (d:Ditta)<-[:APPARTIENE_A]-(:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)-[:INCLUSA_IN]->(fam:Famiglia)
  WHERE toLower(trim(fam.nome)) = 'y'
  RETURN DISTINCT d.dittaId AS ditta
  ORDER BY ditta

  //Companies that purchase family Y (structure level, no totals)
  MATCH (d:Ditta)<-[:APPARTIENE_A]-(:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)-[:INCLUSA_IN]->(fam:Famiglia)
  WHERE toLower(trim(fam.nome)) = 'y'
  RETURN DISTINCT d.dittaId AS ditta
  ORDER BY ditta

  // Number of documents per company
  MATCH (d:Ditta)<-[:APPARTIENE_A]-(:Cliente)-[:HA_RICEVUTO]->(doc:Documento)
  RETURN d.dittaId AS ditta, count(DISTINCT doc) AS numeroDocumenti
  ORDER BY numeroDocumenti DESC

  Final Cypher Query:

CROSS_DOMAIN: |
  You generate Cypher combining sales and purchases (profit/margin, suppliers for sold products, negative patterns).

  Use this specialist for:
  - Profit/margin calculations (revenue - cost)
  - Comparing selling price vs purchase price
  - Finding suppliers for products sold to specific customers
  - Negative patterns (sold but not purchased, or vice versa)
  
  User Question: {question}
  Schema:
  {schema}
  ---
  Examples:
  // Suppliers for products sold to customer X
  MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo)
  WHERE toLower(trim(c.name)) = 'customer_x'
  WITH collect(DISTINCT a) AS articoliVenduti
  MATCH (gf:GruppoFornitore)<-[:RAGGRUPPATO_SOTTO]-(:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a)
  WHERE a IN articoliVenduti
  RETURN DISTINCT gf.ragioneSociale AS fornitore ORDER BY fornitore

  // Sold but never purchased
  MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo)
  WHERE NOT (a)<-[:RIGUARDA_ARTICOLO]-(:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore)
  RETURN DISTINCT a.descrizione AS articolo

  // Products purchased but never sold
  MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore)
  WHERE NOT (a)<-[:RIGUARDA_ARTICOLO]-(:RigaDocumento {{tipoValore:'Fatturato'}})
  RETURN DISTINCT a.descrizione AS prodottoMaiVenduto
  LIMIT 5

 

  // Products purchased but never sold
  MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore)
  WHERE NOT (a)<-[:RIGUARDA_ARTICOLO]-(:RigaDocumento {{tipoValore: 'Fatturato'}})
  RETURN DISTINCT a.descrizione AS prodottoMaiVenduto
  LIMIT 5

  // Suppliers of items sold to the best customer
  MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)
  WHERE dr.tipoValore='Fatturato' AND dr.importo>0
  WITH c, sum(dr.importo) AS fatturato
  ORDER BY fatturato DESC
  LIMIT 1
  MATCH (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo)
  WITH collect(DISTINCT a) AS articoliTop
  MATCH (gf:GruppoFornitore)<-[:RAGGRUPPATO_SOTTO]-(:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(drAcq:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(aVenduto:Articolo)
  WHERE aVenduto IN articoliTop
  RETURN gf.ragioneSociale AS fornitore, sum(drAcq.importo) AS valoreAcquistato
  ORDER BY valoreAcquistato DESC

  Final Cypher Query:
