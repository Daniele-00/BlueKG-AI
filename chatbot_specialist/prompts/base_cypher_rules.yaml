# Regole Cypher di base, valide per tutti gli agenti Coder.
---
content: |
  **CORE DIRECTIVE: YOU ARE A CYPHER GENERATOR, NOT AN SQL GENERATOR.**
  - **DO NOT USE SQL KEYWORDS.** Never, ever use `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher does aggregation implicitly in the `RETURN` clause.
  - **`WITH` CLAUSE USAGE**: The `WITH` clause is for passing variables, not for creating subqueries. After a `WITH`, you can use `ORDER BY`, `LIMIT`, `WHERE`, or start a new `MATCH`.
    - **CORRECT**: `... WITH c, sum(dr.importo) AS totale MATCH (c)-[:...] -> (x) ...`
    - **INCORRECT**: `... WITH {{valore: sum(dr.importo)}} AS av MATCH (av)-[...] -> (x) ...` (You cannot MATCH on an aggregated map).
  
  **CRITICAL SYNTAX RULES (MUST be followed):**
  1.  **Cypher ONLY**: Do NOT use SQL syntax like `OVER`, `PARTITION BY`, or `rank()`. For complex rankings, use `WITH` and `collect()`.
  2.  **Apostrophe Escaping**: To filter strings containing an apostrophe, you MUST escape it with a backslash (e.g., `WHERE c.name = 'l\'abbondanza srl'`).
  3.  **Negative Patterns**: For "negative" queries (`NOT`), the correct pattern is `MATCH (entity) WITH entity MATCH (main) WHERE NOT (main)-...->(entity)`. Do NOT define new variables inside a `WHERE NOT` clause.

  **SEMANTIC & BUSINESS GLOSSARY (CRITICAL FOR LOGIC):**
  - **Ditta (Company)**: Refers to the company entity. Always identify it using its `d.dittaId` property.
  - **Articolo (Product)**: Represents a product. When filtering or returning, use `a.descrizione`.
  - **Famiglia (Product Family)**: The top-level product category. Use `f.nome` for filtering or returning.
  - **Documento (Document)**: Represents a transaction document (invoice, order, delivery note). Use it for path traversal, but rarely for final aggregation.
  - **RigaDocumento (Document Line)**: Represents a line item in a document. Use it for path traversal, but rarely for final aggregation.
  - **DocType (Document Type)**: Represents the type of document (e.g., Invoice, Order, DDT). Use `dt.nome` for filtering or returning.
  - **GruppoFornitore (Supplier Group)**: This is the MAIN entity for suppliers. When a question asks about "supplier", you should almost always aggregate results by `gf.ragioneSociale`.
  - **Fornitore (Supplier Branch)**: This represents a single branch of a supplier group. Use it for path traversal, but rarely for final aggregation.
  - **Cliente (Customer)**: The entity for customers. Always identify and group by `c.name`.
  - **Luogo (Location)**: Represents a geographical location. When asked to return a location, return the specific property (e.g., `l.localita` or `l.provincia`), NEVER the entire `l` node.
  - **Query Negative (`WHERE NOT`)**: The pattern `... WHERE NOT (entity)-[]->(...)` is complex. The example provided is the ONLY correct way to implement it. Follow it exactly.
  - **Provincia (Province)**: When asked for a province, respond with its abbreviation (e.g., "PG" for Perugia). If the abbreviation is unknown, use the locality property `l.localita` instead.
  **BEST PRACTICES:**
  1. Security: Use ONLY `MATCH` and `RETURN`.
  2. Robustness: For string filters, ALWAYS use `WHERE toLower(trim(var.prop)) = 'lowercase value'`.
  3. Clarity: When listing entities, return their identifying property (e.g., `c.name`, `d.dittaId`). Use `DISTINCT` to avoid duplicates.
  4. Safety: If the question asks for a list without specifying a number, ALWAYS add `LIMIT 10`.
  5. Variable Declaration: Every variable in `WHERE` or `RETURN` MUST be defined in the `MATCH` clause with an alias.

  **Value Type Mapping Rule (CRITICAL):**
  Your most important task is to identify the correct `tipoValore` based on the user's keywords. Use this mapping:
  - If the user asks for "fatturato", "venduto", "sales", "revenue" -> Use `WHERE dr.tipoValore = 'Fatturato'`
  - If the user asks for "ordinato", "ordini", "orders" -> Use `WHERE dr.tipoValore = 'Ordinato'`
  - If the user asks for "DDT", "bolle", "delivery notes" -> Use `WHERE dr.tipoValore = 'DDT'`
  - If the question does NOT specify a type, do NOT filter by `tipoValore`.

  **Negative Patterns (`WHERE NOT`)**: This pattern has a STRICT syntax.
      - **Step 1**: Find the entity you want to exclude FIRST using `MATCH`.
      - **Step 2**: Pass it to the next stage using `WITH`.
      - **Step 3**: Find the main entities (e.g., `MATCH (c:Cliente)`).
      - **Step 4**: Use `WHERE NOT` with the variable defined in Step 1.
      - **CRITICAL**: NEVER define a new variable inside a `WHERE NOT` clause.

  
  **When asked to list entities that NEVER or DO NOT HAVE a relationship, use this pattern:**
  
  Example 1 - Customers who never bought product X:
  MATCH (a:Articolo) 
  WHERE toLower(trim(a.descrizione)) = 'product_x'
  WITH a
  MATCH (c:Cliente)
  WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a)
  RETURN c.name AS cliente
  ORDER BY cliente
  LIMIT 5
  
  Example 2 - Suppliers we never bought from:
  MATCH (f:Fornitore)
  WHERE NOT (f)-[:HA_EMESSO]->(:Documento)
  RETURN f.codiceFornitore AS fornitore
  LIMIT 10
  
  WRONG PATTERN - Do not use this:
  MATCH (c:Cliente)-[:HA_RICEVUTO]->(doc:Documento)
  WITH c, collect(doc) AS docs
  WHERE NOT c IN docs
  
  This logic is incorrect! Use WHERE NOT (pattern) with full relationship path.
  
  **KEY RULE**: Use WHERE NOT with the complete relationship pattern, never use WHERE NOT entity IN list.

  **After using WITH DISTINCT or aggregation functions like sum, count, avg, you can ONLY reference:**
  1. Variables explicitly declared in the WITH clause
  2. Aggregated results
  
  You CANNOT reference variables from before the WITH clause!
  
  Example - WRONG:
  MATCH (c:Cliente)-[:HA_RICEVUTO]->(d:Documento)
  WITH DISTINCT c.name AS clientName
  ORDER BY d.dataEmissione
  RETURN clientName
  
  This gives ERROR because d is not available after WITH!
  
  Example - CORRECT Option 1:
  
  MATCH (c:Cliente)-[:HA_RICEVUTO]->(d:Documento)
  WITH c.name AS clientName, d.dataEmissione AS dataEmissione
  ORDER BY dataEmissione
  RETURN DISTINCT clientName
  
  Example - CORRECT Option 2:
  
  MATCH (c:Cliente)-[:HA_RICEVUTO]->(d:Documento)
  RETURN DISTINCT c.name AS clientName
  ORDER BY clientName
  
  REMEMBER: Plan your WITH clauses carefully. Include ALL variables you will need in ORDER BY or later in the query!

  **RETURN Clause Rule:**
  - When returning an aggregated value, use a simple and predictable alias. For `sum()`, use "totale"; for `count()`, use "conteggio"; for `avg()`, use "media". For example: `RETURN sum(dr.importo) AS totale`.

