# Prompt compatti per Llama3: specialist coders
---
SALES_CYCLE: |
  You generate Cypher for SALES/REVENUE questions.

  User Question: {question}
  Schema:
  {schema}
  ---
  RULES:
  - Start from customer path: (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)
  - VALUE vs QUANTITY:
    - Value-based (fatturato, valore venduto, ricavi): filter `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0` and aggregate `sum(dr.importo)`.
    - Quantity-based (quantità, pezzi, unità): aggregate `sum(dr.quantita)` and DO NOT filter by `dr.tipoValore` unless explicitly requested in the question.
  - Customers: group by c.name. Companies: group by d.dittaId via (d)<-[:APPARTIENE_A]-(c)
  - String filters: toLower(trim(...))
  - Rankings: ORDER BY metric DESC LIMIT N (only if N is asked). If the question uses "ogni", "tutte", "per ciascuna", DO NOT add LIMIT and return all groups.
  - Date: use doc.dataEmissione.year when needed
  - Trend questions ("attualmente", crescita/perdita): restrict to the last two years only using `doc.dataEmissione.year IN [date().year, date().year-1]`.
  - Product filters: ALWAYS join via (dr)-[:RIGUARDA_ARTICOLO]->(a:Articolo) and filter a.descrizione
  - Family filters: ALWAYS join via (a)-[:APPARTIENE_A]->(:Sottofamiglia)-[:INCLUSA_IN]->(fam:Famiglia) and filter toLower(trim(fam.nome)). NEVER filter a.descrizione when the question mentions "famiglia".
  - If the question contains "quanti", "numero di", "conta", "unici" → use count(DISTINCT ...), do NOT return lists
  - Avoid unnecessary WITH: if a single MATCH + RETURN suffices, do not insert a WITH. Use WITH only to pass aggregated values or limit variables for the next stage.

  Examples:
  // Top customer by revenue
  MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)
  WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0
  RETURN c.name AS cliente, sum(dr.importo) AS fatturato
  ORDER BY fatturato DESC
  LIMIT 1

  // Revenue per company
  MATCH (d:Ditta)<-[:APPARTIENE_A]-(c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)
  WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0
  RETURN d.dittaId AS ditta, sum(dr.importo) AS fatturato
  ORDER BY fatturato DESC, d.dittaId ASC

  // Top N products by quantity sold
  MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo)
  RETURN a.descrizione AS prodotto, sum(dr.quantita) AS quantitaTotale
  ORDER BY quantitaTotale DESC
  LIMIT 5

  // Price sold for a specific product X
  MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo)
  WHERE toLower(trim(a.descrizione)) = 'x' AND dr.tipoValore='Fatturato' AND dr.importo>0
  RETURN sum(dr.importo) AS totaleVenduto

  // Turnover by month in the current year
  MATCH (:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)
  WHERE dr.tipoValore='Fatturato' AND dr.importo>0 AND doc.dataEmissione.year = date().year
  RETURN doc.dataEmissione.month AS mese, sum(dr.importo) AS fatturatoMensile
  ORDER BY mese

  // Best year per company 
  MATCH (d:Ditta)<-[:APPARTIENE_A]-(:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)
  WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0
  WITH d, doc.dataEmissione.year AS anno, sum(dr.importo) AS fatturatoAnnuale
  ORDER BY d.dittaId, fatturatoAnnuale DESC
  WITH d, collect({{anno: anno, fatturato: fatturatoAnnuale}}) AS fatturatiOrdinati
  RETURN d.dittaId AS ditta, fatturatiOrdinati[0].anno AS annoTop, fatturatiOrdinati[0].fatturato AS fatturatoMassimo
  // Do NOT add LIMIT here: return all companies

  // Compare turnover between two specific years
  MATCH (:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)
  WHERE dr.tipoValore='Fatturato' AND dr.importo>0 AND doc.dataEmissione.year IN [2023, 2024]
  RETURN doc.dataEmissione.year AS anno, sum(dr.importo) AS fatturatoTotale
  ORDER BY anno

  // Companies that sell product of family X
  MATCH (d:Ditta)<-[:APPARTIENE_A]-(:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)-[:INCLUSA_IN]->(fam:Famiglia)
  WHERE toLower(trim(fam.nome)) = 'x'
  RETURN DISTINCT d.dittaId AS ditta
  ORDER BY ditta

  // Revenue for family X
  MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)-[:INCLUSA_IN]->(fam:Famiglia)
  WHERE toLower(trim(fam.nome)) = 'elettrodomestici' AND dr.tipoValore='Fatturato' AND dr.importo>0
  RETURN sum(dr.importo) AS fatturatoFamiglia
  
  // Locality with most customers
  MATCH (c:Cliente)-[:HAS_ADDRESS]->(l:Luogo)
  WHERE l.localita IS NOT NULL
  RETURN l.localita AS localita, count(DISTINCT c) AS numeroClientiUnici
  ORDER BY numeroClientiUnici DESC 
  LIMIT 1
PURCHASE_CYCLE: |
  You generate Cypher for PURCHASES/COST questions.

  User Question: {question}
  Schema:
  {schema}
  ---
  RULES:
  - Start from supplier path: (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)
  - Group suppliers by GruppoFornitore: (gf:GruppoFornitore)<-[:RAGGRUPPATO_SOTTO]-(f:Fornitore)
  - VALUE vs QUANTITY:
    - Value-based (costo, speso, pagato, valore acquistato): aggregate `sum(dr.importo)`; no `tipoValore` filter unless explicitly requested.
    - Quantity-based (quantità acquistata, "più acquistata" in termini di quantità): aggregate `sum(dr.quantita)`; DO NOT add `tipoValore` filters unless explicitly requested.
  - String filters: toLower(trim(...))
  - Avoid re-matching after an aggregation that may multiply rows; prefer single MATCH + RETURN or proper scoping
  - When counting documents by supplier or supplier group, prefer count(DISTINCT doc) to avoid duplicates due to joins.
  - Avoid unnecessary WITH: prefer one-stage MATCH + RETURN if possible; use WITH only when you need to pass aggregates/variables to a following stage.

  Examples:
  // Total bought from supplier X
  MATCH (gf:GruppoFornitore)<-[:RAGGRUPPATO_SOTTO]-(:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)
  WHERE toLower(trim(gf.ragioneSociale)) = 'fornitore esempio spa'
  RETURN sum(dr.importo) AS totaleAcquistato

  // Most purchased family
  MATCH (:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)-[:INCLUSA_IN]->(f:Famiglia)
  RETURN f.nome AS famiglia, sum(dr.quantita) AS quantitaTotale
  ORDER BY quantitaTotale DESC
  LIMIT 1

  // Locality with most suppliers
  MATCH (f:Fornitore)-[:SI_TROVA_A]->(l:Luogo)
  WHERE l.localita IS NOT NULL
  RETURN l.localita AS localita, count(DISTINCT f) AS numeroFornitori
  ORDER BY numeroFornitori DESC LIMIT 1

  // Total cost for a specific product 
  MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore)
  WHERE toLower(trim(a.descrizione)) = 'gas freon solstice n40 r448a'
  RETURN sum(dr.importo) AS costoTotaleAcquisto

  // Supplier with most documents
  MATCH (gf:GruppoFornitore)<-[:RAGGRUPPATO_SOTTO]-(:Fornitore)-[:HA_EMESSO]->(doc:Documento)
  RETURN gf.ragioneSociale AS fornitore, count(DISTINCT doc) AS numeroDocumenti
  ORDER BY numeroDocumenti DESC
  LIMIT 1

  // Purchase price of the product X
  MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore)
  WHERE toLower(trim(a.descrizione)) = 'gas freon solstice n40 r448a'
  RETURN sum(dr.importo) AS prezzoAcquisto

  // Supplier most active in the last quarter (by value)
  WITH date() - duration({{months: 3}}) AS dataInizio
  MATCH (gf:GruppoFornitore)<-[:RAGGRUPPATO_SOTTO]-(:Fornitore)-[:HA_EMESSO]->(doc:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)
  WHERE doc.dataEmissione >= dataInizio
  RETURN gf.ragioneSociale AS fornitore, sum(dr.importo) AS valoreAcquistato
  ORDER BY valoreAcquistato DESC
  LIMIT 1

  Final Cypher Query:

GENERAL_QUERY: |
  You generate SIMPLE Cypher listings (no aggregations).

  User Question: {question}
  Schema:
  {schema}
  ---
  RULES:
  - List or lookup only; 
  - Use DISTINCT to avoid duplicates
  - String filters with toLower(trim(...))
  - ORDER BY result; LIMIT 20 if large lists
  - Use SUM, AVG, COUNT only for explicit counts/averages in question (examples words: "how many", "number of", "average", "media", "count")
  - ORDER BY with DISTINCT: if you `RETURN DISTINCT doc.documentoId AS documento`, either `ORDER BY documento`, or pre-order with `WITH doc ORDER BY doc.dataEmissione` and then `RETURN DISTINCT doc.documentoId AS documento`.


  // Products in family 'X'
  MATCH (f:Famiglia)<-[:INCLUSA_IN]-(:Sottofamiglia)<-[:APPARTIENE_A]-(a:Articolo)
  WHERE toLower(trim(f.nome)) = 'X'
  RETURN DISTINCT a.descrizione AS prodotto ORDER BY prodotto

  // Locality filter (use l.localita)
  MATCH (c:Cliente)-[:HAS_ADDRESS]->(l:Luogo)
  WHERE toLower(trim(l.localita)) = 'perugia'
  RETURN DISTINCT c.name AS cliente ORDER BY cliente LIMIT 5

  // Documents of type FVC in January 2025 for a given customer (ORDER BY + DISTINCT safe pattern)
  MATCH (c:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:IS_TYPE]->(dt:DocType)
  WHERE toLower(trim(c.name)) = 'l\'abbondanza srl' AND dt.codice = 'FVC' AND doc.dataEmissione.year = 2025 AND doc.dataEmissione.month = 1
  WITH doc
  ORDER BY doc.dataEmissione
  RETURN DISTINCT doc.documentoId AS documento
  LIMIT 10



  Final Cypher Query:

DITTE_QUERY: |
  You generate Cypher focused on company (ditta) structure, listings, and basic counts (non-monetary).

  User Question: {question}
  Schema:
  {schema}
  ---
  RULES:
  - Always anchor on (d:Ditta) and traverse via Cliente/Fornitore only for structural info (no sums of importi)
  - For counts ("quanti", "numero di", "conta") use count(DISTINCT ...)
  - For listings, use DISTINCT + ORDER BY + LIMIT 20 when appropriate
  - Do NOT perform sales/purchase aggregations here (no sum(dr.importo)); if monetario richiesto, route to SALES_CYCLE or PURCHASE_CYCLE
  - String filters: toLower(trim(...))
  - Family filters: when the question mentions a product family, use the path (a:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)-[:INCLUSA_IN]->(fam:Famiglia) and filter toLower(trim(fam.nome)).

  Examples:
  // Unique customers of company X
  MATCH (d:Ditta {{dittaId: 'X'}})<-[:APPARTIENE_A]-(c:Cliente)
  RETURN count(DISTINCT c) AS numeroClientiUnici

  // List companies (ditte)
  MATCH (d:Ditta)
  RETURN d.dittaId AS ditta
  ORDER BY ditta
  LIMIT 20

  // Sort companies by number of sales documents
  MATCH (d:Ditta)<-[:APPARTIENE_A]-(:Cliente)-[:HA_RICEVUTO]->(doc:Documento)
  RETURN d.dittaId AS ditta, count(doc) AS numeroDocumenti
  ORDER BY numeroDocumenti DESC

  // Companies that sell family Y 
  MATCH (d:Ditta)<-[:APPARTIENE_A]-(:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)-[:INCLUSA_IN]->(fam:Famiglia)
  WHERE toLower(trim(fam.nome)) = 'y'
  RETURN DISTINCT d.dittaId AS ditta
  ORDER BY ditta

  //Companies that purchase family Y
  MATCH (d:Ditta)<-[:APPARTIENE_A]-(:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)-[:INCLUSA_IN]->(fam:Famiglia)
  WHERE toLower(trim(fam.nome)) = 'y'
  RETURN DISTINCT d.dittaId AS ditta
  ORDER BY ditta


  Final Cypher Query:

CROSS_DOMAIN: |
  You generate Cypher combining sales and purchases (profit/margin, suppliers for sold products, negative patterns).

  User Question: {question}
  Schema:
  {schema}
  ---
  Examples:
  // Suppliers for products sold to customer X
  MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo)
  WHERE toLower(trim(c.name)) = 'customer_x'
  WITH collect(DISTINCT a) AS articoliVenduti
  MATCH (gf:GruppoFornitore)<-[:RAGGRUPPATO_SOTTO]-(:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a)
  WHERE a IN articoliVenduti
  RETURN DISTINCT gf.ragioneSociale AS fornitore ORDER BY fornitore

  
  // Trend belongs to SALES_CYCLE (see SALES_CYCLE section)

  // Sold but never purchased
  MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo)
  WHERE NOT (a)<-[:RIGUARDA_ARTICOLO]-(:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore)
  RETURN DISTINCT a.descrizione AS articolo

  // Products purchased but never sold
  MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore)
  WHERE NOT (a)<-[:RIGUARDA_ARTICOLO]-(:RigaDocumento {{tipoValore:'Fatturato'}})
  RETURN DISTINCT a.descrizione AS prodottoMaiVenduto
  LIMIT 5
  ORDER BY prodottoMaiVenduto

  // Suppliers of items sold to the best customer
  MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)
  WHERE dr.tipoValore='Fatturato' AND dr.importo>0
  WITH c, sum(dr.importo) AS fatturato
  ORDER BY fatturato DESC
  LIMIT 1
  MATCH (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo)
  WITH collect(DISTINCT a) AS articoliTop
  MATCH (gf:GruppoFornitore)<-[:RAGGRUPPATO_SOTTO]-(:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(drAcq:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(aVenduto:Articolo)
  WHERE aVenduto IN articoliTop
  RETURN gf.ragioneSociale AS fornitore, sum(drAcq.importo) AS valoreAcquistato
  ORDER BY valoreAcquistato DESC

  Final Cypher Query:
