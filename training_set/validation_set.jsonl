{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto MX23FB COMPR.ELECTROLUX?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'mx23fb compr.electrolux' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quali fornitori ci forniscono prodotti venduti al cliente 'VINCENTI GATTI GIULIANO'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(c.name)) = 'vincenti gatti giuliano' WITH collect(DISTINCT a) AS articoliVenduti MATCH (gf:GruppoFornitore)<-[:RAGGRUPPATO_SOTTO]-(:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WHERE a IN articoliVenduti RETURN DISTINCT gf.ragioneSociale AS fornitore ORDER BY fornitore"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'RESISTENZA RAME W1500 V220'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'resistenza rame w1500 v220' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto COMPRESSORE ASPERA NJ9226GS?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compressore aspera nj9226gs' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'UNITA' CARENATA UTFACA D 313.1Y'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' carenata utfaca d 313.1y' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto GAS FREON SOLSTICE N40 R448A?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'gas freon solstice n40 r448a' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Mostrami i documenti di tipo 'FVC' emessi a gennaio 2025 per il cliente 'SHENZHENSHIXIAOHUANDIANZISHAGWUYOUXIANGONGSI'"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:IS_TYPE]->(dt:DocType) WHERE toLower(trim(c.name)) = 'shenzhenshixiaohuandianzishagwuyouxiangongsi' AND dt.codice = 'FVC' AND doc.dataEmissione.year = 2025 AND doc.dataEmissione.month = 1 RETURN doc.documentoinstruction AS documento"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto COMPR.ELECTROLUX GP12TB R134?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.electrolux gp12tb r134' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quali aziende vendono prodotti della famiglia 'EVAPORATORI'?"}, {"role": "assistant", "content": "MATCH (d:Ditta)<-[:APPARTIENE_A]-(:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)-[:INCLUSA_IN]->(fam:Famiglia) WHERE toLower(trim(fam.nome)) = 'evaporatori' RETURN DISTINCT d.dittaId AS ditta ORDER BY ditta"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto FABBRICATORE DI GHIACCIO S550W?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'fabbricatore di ghiaccio s550w' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto UNITA' COND.ERMET.TEAV J6220Z?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' cond.ermet.teav j6220z' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'COMPRESSORE A VITE V4'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compressore a vite v4' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto UNITA' CONDENSATRICE?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' condensatrice' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Calcola il rapporto tra costo totale e fatturato totale per il prodotto 'COMPR.ASPERA NE6170Z'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera ne6170z' OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_acq:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WITH a, sum(dr_acq.importo) AS costoTotale OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_ven:RigaDocumento {tipoValore: 'Fatturato'})<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_RICEVUTO]-(:Cliente) WHERE dr_ven.importo > 0 WITH costoTotale, sum(dr_ven.importo) AS fatturatoTotale RETURN costoTotale, fatturatoTotale, (fatturatoTotale / costoTotale) AS rapporto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quali sono i 3 prodotti più venduti al cliente 'CLIENTE PROVA SRL'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(c.name)) = 'cliente prova srl' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN a.descrizione AS prodotto, sum(dr.importo) AS totaleVenduto ORDER BY totaleVenduto DESC LIMIT 3"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca le sottofamiglie della famiglia 'TERMOSTATI'"}, {"role": "assistant", "content": "MATCH (f:Famiglia)<-[:INCLUSA_IN]-(sf:Sottofamiglia) WHERE toLower(trim(f.nome)) = 'termostati' RETURN DISTINCT sf.nome AS sottofamiglia ORDER BY sottofamiglia"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto COMPRESSORE ASPERA E2134ECSR?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compressore aspera e2134ecsr' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Trova i fornitori che non ci hanno mai venduto prodotti della famiglia 'BANCO FRIGO'"}, {"role": "assistant", "content": "MATCH (fam:Famiglia) WHERE toLower(trim(fam.nome)) = 'banco frigo' WITH fam MATCH (gf:GruppoFornitore) WHERE NOT (gf)<-[:RAGGRUPPATO_SOTTO]-(:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)-[:INCLUSA_IN]->(fam) RETURN gf.ragioneSociale AS fornitore"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il margine di profitto del prodotto 'UNITA' ARIA SEMIERM.UTFA 2A0.75Y'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr1:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' aria semierm.utfa 2a0.75y' AND dr1.tipoValore = 'Fatturato' AND dr1.importo > 0 WITH a, sum(dr1.importo) AS fatturato MATCH (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WITH a, fatturato, sum(dr2.importo) AS costo RETURN a.descrizione AS prodotto, fatturato, costo, (fatturato - costo) AS margine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 50 prodotti che abbiamo acquistato ma mai venduto"}, {"role": "assistant", "content": "MATCH (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE NOT EXISTS { MATCH (a)<-[:RIGUARDA_ARTICOLO]-(:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_RICEVUTO]-(:Cliente) } RETURN DISTINCT a.descrizione AS prodotto ORDER BY prodotto LIMIT 50"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto UNITA' ASPERA UE9213GK?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' aspera ue9213gk' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho speso per acquistare il prodotto KIT GUAR.TALLONE MAGN.C/MAG.20?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'kit guar.tallone magn.c/mag.20' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho speso per acquistare il prodotto UNITA' CARENATA UTFACALC 2 B 1,59.1Y-LLD?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'unita' carenata utfacalc 2 b 1,59.1y-lld' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quali aziende vendono prodotti della famiglia 'BANCO FRIGO'?"}, {"role": "assistant", "content": "MATCH (d:Ditta)<-[:APPARTIENE_A]-(:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)-[:INCLUSA_IN]->(fam:Famiglia) WHERE toLower(trim(fam.nome)) = 'banco frigo' RETURN DISTINCT d.dittaId AS ditta ORDER BY ditta"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'COMPR.MANEUROP. MTZ40JH 4VE R404'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.maneurop. mtz40jh 4ve r404' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto COMPR.ASPERA NE6210GK?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera ne6210gk' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'COMPRESSORE ASPERA NJ9226GS'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compressore aspera nj9226gs' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'UNITA' ASPERA UJ2192GK'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' aspera uj2192gk' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto COMPR.BITZER 4TC82Y40?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.bitzer 4tc82y40' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il fatturato totale del cliente ARISTON SNC?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE toLower(trim(c.name)) = 'ariston snc' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS fatturatoTotale"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Calcola il rapporto tra costo totale e fatturato totale per il prodotto 'COMPR.ELECTROLUX ML90TB'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.electrolux ml90tb' OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_acq:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WITH a, sum(dr_acq.importo) AS costoTotale OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_ven:RigaDocumento {tipoValore: 'Fatturato'})<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_RICEVUTO]-(:Cliente) WHERE dr_ven.importo > 0 WITH costoTotale, sum(dr_ven.importo) AS fatturatoTotale RETURN costoTotale, fatturatoTotale, (fatturatoTotale / costoTotale) AS rapporto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 3 clienti che si trovano a Perugia"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HAS_ADDRESS]->(l:Luogo) WHERE toLower(trim(l.localita)) = 'perugia' RETURN DISTINCT c.name AS cliente ORDER BY cliente LIMIT 3"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto COMPR.ASPERA T2168E?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera t2168e' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Dimmi il bollato di ciascuna azienda."}, {"role": "assistant", "content": "MATCH (d:Ditta)<-[:APPARTIENE_A]-(:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE dr.tipoValore = 'Bollato' AND dr.importo > 0 RETURN d.dittaId AS ditta, sum(dr.importo) AS fatturatoTotale ORDER BY fatturatoTotale DESC"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Per ogni famiglia di prodotto, chi è il cliente che ha generato il fatturato maggiore?"}, {"role": "assistant", "content": "MATCH (fam:Famiglia)<-[:INCLUSA_IN]-(:Sottofamiglia)<-[:APPARTIENE_A]-(:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_RICEVUTO]-(c:Cliente) WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0 WITH fam, c, sum(dr.importo) AS fatturato ORDER BY fam.nome, fatturato DESC WITH fam, collect({cliente: c.name, fatturato: fatturato}) AS clientiOrdinati RETURN fam.nome AS famiglia, clientiOrdinati[0].cliente AS topCliente, clientiOrdinati[0].fatturato AS fatturatoMassimo"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto TENDINA MAN T FOR L2500?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'tendina man t for l2500' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'COMPR.ASPERA T2180GK'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera t2180gk' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Calcola il rapporto tra costo totale e fatturato totale per il prodotto 'COMPR.ASPERA J6226 ECR'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera j6226 ecr' OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_acq:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WITH a, sum(dr_acq.importo) AS costoTotale OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_ven:RigaDocumento {tipoValore: 'Fatturato'})<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_RICEVUTO]-(:Cliente) WHERE dr_ven.importo > 0 WITH costoTotale, sum(dr_ven.importo) AS fatturatoTotale RETURN costoTotale, fatturatoTotale, (fatturatoTotale / costoTotale) AS rapporto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto COMPR.ASPERA NEK2150GK?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'compr.aspera nek2150gk' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto COMPR ASPERA NE9213GK?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr aspera ne9213gk' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il margine di profitto del prodotto 'COMPR.ASPERA NE6170Z'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr1:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera ne6170z' AND dr1.tipoValore = 'Fatturato' AND dr1.importo > 0 WITH a, sum(dr1.importo) AS fatturato MATCH (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WITH a, fatturato, sum(dr2.importo) AS costo RETURN a.descrizione AS prodotto, fatturato, costo, (fatturato - costo) AS margine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto COMPRESSORE ASPERA NB2118Z?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compressore aspera nb2118z' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto SERB.ACC A/REFR.LT1000?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'serb.acc a/refr.lt1000' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca i clienti dell'azienda '1' situati nella provincia di 'TO'"}, {"role": "assistant", "content": "MATCH (d:Ditta {dittaId: '1'})<-[:APPARTIENE_A]-(c:Cliente)-[:HAS_ADDRESS]->(l:Luogo) WHERE toLower(trim(l.provincia)) = 'to' RETURN c.name AS cliente ORDER BY cliente"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto COMPR.ASPERA J6226Z?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera j6226z' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il margine di profitto del prodotto 'UNITA' COND.UB6 144Z 02 R134'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr1:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' cond.ub6 144z 02 r134' AND dr1.tipoValore = 'Fatturato' AND dr1.importo > 0 WITH a, sum(dr1.importo) AS fatturato MATCH (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WITH a, fatturato, sum(dr2.importo) AS costo RETURN a.descrizione AS prodotto, fatturato, costo, (fatturato - costo) AS margine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'FABBRICATORE DI GHIACCIO SGS600'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'fabbricatore di ghiaccio sgs600' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto UNITAA' COND.ERTM.TEAV NE6187Z?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'unitaa' cond.ertm.teav ne6187z' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto FABBRICATORE DI GHIACCIO SGS600?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'fabbricatore di ghiaccio sgs600' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quali sono i 3 prodotti più venduti al cliente 'SG IMPIANTI DI ANDREA GIUSEPPONI'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(c.name)) = 'sg impianti di andrea giusepponi' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN a.descrizione AS prodotto, sum(dr.importo) AS totaleVenduto ORDER BY totaleVenduto DESC LIMIT 3"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il fatturato totale del cliente MEMORYKING GMBH & CO. KG?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE toLower(trim(c.name)) = 'memoryking gmbh & co. kg' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS fatturatoTotale"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto UNITA' ASPERA UJ2212GS?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' aspera uj2212gs' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quali aziende vendono prodotti della famiglia 'MOTOCOMPRESSORI'?"}, {"role": "assistant", "content": "MATCH (d:Ditta)<-[:APPARTIENE_A]-(:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)-[:INCLUSA_IN]->(fam:Famiglia) WHERE toLower(trim(fam.nome)) = 'motocompressori' RETURN DISTINCT d.dittaId AS ditta ORDER BY ditta"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto COMNPR.ELECTROLUX GS34TB?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'comnpr.electrolux gs34tb' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Calcola il rapporto tra costo totale e fatturato totale per il prodotto 'NJ2212GS R404 ASPERA'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'nj2212gs r404 aspera' OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_acq:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WITH a, sum(dr_acq.importo) AS costoTotale OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_ven:RigaDocumento {tipoValore: 'Fatturato'})<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_RICEVUTO]-(:Cliente) WHERE dr_ven.importo > 0 WITH costoTotale, sum(dr_ven.importo) AS fatturatoTotale RETURN costoTotale, fatturatoTotale, (fatturatoTotale / costoTotale) AS rapporto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quali sono i 3 prodotti più venduti al cliente 'ZYXEL NETWORKS A/S'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(c.name)) = 'zyxel networks a/s' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN a.descrizione AS prodotto, sum(dr.importo) AS totaleVenduto ORDER BY totaleVenduto DESC LIMIT 3"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca le province che non hanno né clienti né fornitori."}, {"role": "assistant", "content": "MATCH (l:Luogo) WHERE l.provincia IS NOT NULL WITH collect(DISTINCT l.provincia) AS tutteLeProvince MATCH (c:Cliente)-[:HAS_ADDRESS]->(lc:Luogo) WITH tutteLeProvince, collect(DISTINCT lc.provincia) AS provinceClienti MATCH (f:Fornitore)-[:SI_TROVA_A]->(lf:Luogo) WITH tutteLeProvince, provinceClienti, collect(DISTINCT lf.provincia) AS provinceFornitori CALL apoc.coll.subtract(tutteLeProvince, apoc.coll.union(provinceClienti, provinceFornitori)) YIELD value RETURN value AS provinciaVuota"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Dimmi il fatturato di ciascuna azienda."}, {"role": "assistant", "content": "MATCH (d:Ditta)<-[:APPARTIENE_A]-(:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN d.dittaId AS ditta, sum(dr.importo) AS fatturatoTotale ORDER BY fatturatoTotale DESC"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto COMPRESSORE ASPERA NB2118Z?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compressore aspera nb2118z' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Per i primi 5 clienti per fatturato, mostra il loro prodotto più acquistato per valore."}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0 WITH c, sum(dr.importo) AS fatturatoTotale ORDER BY fatturatoTotale DESC LIMIT 5 MATCH (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE dr2.tipoValore = 'Fatturato' AND dr2.importo > 0 WITH c, a, sum(dr2.importo) AS valoreProdotto ORDER BY c.name, valoreProdotto DESC WITH c, collect({prodotto: a.descrizione, valore: valoreProdotto})[0] AS prodottoTop RETURN c.name AS cliente, prodottoTop.prodotto AS prodottoPiuAcquistato, prodottoTop.valore"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Confronta il fatturato totale del 2023 con quello del 2023."}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0 AND doc.dataEmissione.year IN [2023, 2023] RETURN doc.dataEmissione.year AS anno, sum(dr.importo) AS fatturatoTotale ORDER BY anno"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il margine di profitto del prodotto 'COMPR.ASPERA J6220GK'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr1:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera j6220gk' AND dr1.tipoValore = 'Fatturato' AND dr1.importo > 0 WITH a, sum(dr1.importo) AS fatturato MATCH (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WITH a, fatturato, sum(dr2.importo) AS costo RETURN a.descrizione AS prodotto, fatturato, costo, (fatturato - costo) AS margine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il fatturato totale del cliente RN ELETTRICA di NIKOLLA ROBERT?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE toLower(trim(c.name)) = 'rn elettrica di nikolla robert' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS fatturatoTotale"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho speso per acquistare il prodotto COMPR. ASPERA BP1084Z?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'compr. aspera bp1084z' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto UNITA'COND.ERMET.TEAV2 J9238GK?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'unita'cond.ermet.teav2 j9238gk' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il margine di profitto del prodotto 'COMPRESSORE NT6220GK'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr1:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compressore nt6220gk' AND dr1.tipoValore = 'Fatturato' AND dr1.importo > 0 WITH a, sum(dr1.importo) AS fatturato MATCH (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WITH a, fatturato, sum(dr2.importo) AS costo RETURN a.descrizione AS prodotto, fatturato, costo, (fatturato - costo) AS margine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho speso per acquistare il prodotto COMPE.ELECTROLUX GL80TB?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'compe.electrolux gl80tb' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il margine di profitto del prodotto 'COMPR.NB6165ECSIR'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr1:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.nb6165ecsir' AND dr1.tipoValore = 'Fatturato' AND dr1.importo > 0 WITH a, sum(dr1.importo) AS fatturato MATCH (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WITH a, fatturato, sum(dr2.importo) AS costo RETURN a.descrizione AS prodotto, fatturato, costo, (fatturato - costo) AS margine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto COMPR.ASPERA NE6170Z?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'compr.aspera ne6170z' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto COMPR.ASPERA J6226 ECR?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera j6226 ecr' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto COMPRESSORE ELECTROLUX MP 14TB?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compressore electrolux mp 14tb' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Il fatturato di ciascuna azienda, nel loro anno migliore"}, {"role": "assistant", "content": "MATCH (d:Ditta)<-[:APPARTIENE_A]-(:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0 WITH d, doc.dataEmissione.year AS anno, sum(dr.importo) AS fatturatoAnnuale ORDER BY d.dittaId, fatturatoAnnuale DESC WITH d, collect({anno: anno, fatturato: fatturatoAnnuale}) AS fatturatiOrdinati RETURN d.dittaId AS ditta, fatturatiOrdinati[0].anno AS annoTop, fatturatiOrdinati[0].fatturato AS fatturatoMassimo"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quali sono i 3 prodotti più venduti al cliente 'ALESPRING IMMOBILIARE SRL'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(c.name)) = 'alespring immobiliare srl' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN a.descrizione AS prodotto, sum(dr.importo) AS totaleVenduto ORDER BY totaleVenduto DESC LIMIT 3"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Mostrami 10 documenti di tipo 'FVC' emessi a Gennaio 2025 al cliente 'HU NAN JING WEI GONG MAO YOU XIAN GONG SI'"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:IS_TYPE]->(dt:DocType) WHERE toLower(trim(c.name)) = 'hu nan jing wei gong mao you xian gong si' AND dt.codice = 'FVC' AND doc.dataEmissione.year = 2025 AND doc.dataEmissione.month = 1 RETURN doc.documentoinstruction AS documento LIMIT 10"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il margine di profitto del prodotto 'UNITA' COND.ERMET.TEAV 2192GK'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr1:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' cond.ermet.teav 2192gk' AND dr1.tipoValore = 'Fatturato' AND dr1.importo > 0 WITH a, sum(dr1.importo) AS fatturato MATCH (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WITH a, fatturato, sum(dr2.importo) AS costo RETURN a.descrizione AS prodotto, fatturato, costo, (fatturato - costo) AS margine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quali fornitori ci forniscono prodotti venduti al cliente 'BIANCHI & FIGLI'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(c.name)) = 'bianchi & figli' WITH collect(DISTINCT a) AS articoliVenduti MATCH (gf:GruppoFornitore)<-[:RAGGRUPPATO_SOTTO]-(:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WHERE a IN articoliVenduti RETURN DISTINCT gf.ragioneSociale AS fornitore ORDER BY fornitore"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quali ditte vendono prodotti della famiglia 'N/D'?"}, {"role": "assistant", "content": "MATCH (d:Ditta)<-[:APPARTIENE_A]-(:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)-[:INCLUSA_IN]->(fam:Famiglia) WHERE toLower(trim(fam.nome)) = 'n/d' RETURN DISTINCT d.dittaId AS ditta ORDER BY ditta"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Mostrami i documenti di tipo 'FVC' emessi a gennaio 2025 per il cliente 'ARRENI THE BEST SAS'"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:IS_TYPE]->(dt:DocType) WHERE toLower(trim(c.name)) = 'arreni the best sas' AND dt.codice = 'FVC' AND doc.dataEmissione.year = 2025 AND doc.dataEmissione.month = 1 RETURN doc.documentoinstruction AS documento"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quali fornitori ci forniscono prodotti venduti al cliente 'SHEN ZHEN SHI HUA NUO SHI TING KE JI YOU XIAN GONG SI'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(c.name)) = 'shen zhen shi hua nuo shi ting ke ji you xian gong si' WITH collect(DISTINCT a) AS articoliVenduti MATCH (gf:GruppoFornitore)<-[:RAGGRUPPATO_SOTTO]-(:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WHERE a IN articoliVenduti RETURN DISTINCT gf.ragioneSociale AS fornitore ORDER BY fornitore"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Confronta il fatturato totale del 2024 con quello del 2024."}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0 AND doc.dataEmissione.year IN [2024, 2024] RETURN doc.dataEmissione.year AS anno, sum(dr.importo) AS fatturatoTotale ORDER BY anno"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Mostrami i documenti di tipo 'FVC' emessi a gennaio 2025 per il cliente 'MICHAEL RUDEL'"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:IS_TYPE]->(dt:DocType) WHERE toLower(trim(c.name)) = 'michael rudel' AND dt.codice = 'FVC' AND doc.dataEmissione.year = 2025 AND doc.dataEmissione.month = 1 RETURN doc.documentoinstruction AS documento"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'COMPR.ASPERA NJ9232GK'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera nj9232gk' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Mostrami 10 documenti di tipo 'FVC' emessi a Gennaio 2025 al cliente 'ROSSI SPA'"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:IS_TYPE]->(dt:DocType) WHERE toLower(trim(c.name)) = 'rossi spa' AND dt.codice = 'FVC' AND doc.dataEmissione.year = 2025 AND doc.dataEmissione.month = 1 RETURN doc.documentoinstruction AS documento LIMIT 10"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto CESTONE D190?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'cestone d190' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto COMPR.ASPERA NT2192GK?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera nt2192gk' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Calcola il rapporto tra costo totale e fatturato totale per il prodotto 'TENDINA MAN T FOR L2500'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'tendina man t for l2500' OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_acq:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WITH a, sum(dr_acq.importo) AS costoTotale OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_ven:RigaDocumento {tipoValore: 'Fatturato'})<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_RICEVUTO]-(:Cliente) WHERE dr_ven.importo > 0 WITH costoTotale, sum(dr_ven.importo) AS fatturatoTotale RETURN costoTotale, fatturatoTotale, (fatturatoTotale / costoTotale) AS rapporto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quali fornitori ci forniscono prodotti venduti al cliente 'SIEC SRL'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(c.name)) = 'siec srl' WITH collect(DISTINCT a) AS articoliVenduti MATCH (gf:GruppoFornitore)<-[:RAGGRUPPATO_SOTTO]-(:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WHERE a IN articoliVenduti RETURN DISTINCT gf.ragioneSociale AS fornitore ORDER BY fornitore"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto COMPR.ASPERA NE 6181 ECSIR?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera ne 6181 ecsir' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto GAS FREON SOLSTICE N40 R448A?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'gas freon solstice n40 r448a' AND dr.tipoValore = 'Ordinato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'COMPR.ASPERA NJ9238GS'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera nj9238gs' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto COMPRESSORE ASPERA J9226P?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compressore aspera j9226p' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto COMPR.ASPERA NJ2212GK?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera nj2212gk' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Mostrami tutti gli ordini fornitori (OF) per maggio 2023."}, {"role": "assistant", "content": "MATCH (doc:Documento)-[:IS_TYPE]->(dt:DocType {codice: 'OF'}) WHERE doc.dataEmissione.year = 2023 AND doc.dataEmissione.month = 5 RETURN doc.documentoinstruction AS ordine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il bollato totale associato ai documenti di tipo 'FVC'?"}, {"role": "assistant", "content": "MATCH (doc:Documento)-[:IS_TYPE]->(dt:DocType {codice: 'FVC'}) MATCH (doc)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE dr.tipoValore = 'Bollato' AND dr.importo > 0 RETURN sum(dr.importo) AS fatturatoFVC"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il margine di profitto del prodotto 'UNITA' ERMETICA UE6187Z-02'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr1:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' ermetica ue6187z-02' AND dr1.tipoValore = 'Fatturato' AND dr1.importo > 0 WITH a, sum(dr1.importo) AS fatturato MATCH (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WITH a, fatturato, sum(dr2.importo) AS costo RETURN a.descrizione AS prodotto, fatturato, costo, (fatturato - costo) AS margine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto COMPR.FRASCOLD A 0.75Y?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'compr.frascold a 0.75y' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'UNITA' COND.UJ9232GS ASPERA'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' cond.uj9232gs aspera' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto UNITAA' COND.ERTM.TEAV NE6187Z?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unitaa' cond.ertm.teav ne6187z' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'COMPRESSORE ASPERA NE9213'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compressore aspera ne9213' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'FABBRICATORE DI GHIACCIO SB90A'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'fabbricatore di ghiaccio sb90a' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto COMPRESSORE ELECTROLUX MP 14TB?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compressore electrolux mp 14tb' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quali ditte vendono prodotti della famiglia 'GRUPPI FRIGO'?"}, {"role": "assistant", "content": "MATCH (d:Ditta)<-[:APPARTIENE_A]-(:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)-[:INCLUSA_IN]->(fam:Famiglia) WHERE toLower(trim(fam.nome)) = 'gruppi frigo' RETURN DISTINCT d.dittaId AS ditta ORDER BY ditta"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto FABBRICATORE SPS701 R.01?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'fabbricatore sps701 r.01' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Per ogni famiglia di prodotto, chi è il cliente che ha generato il bollato maggiore?"}, {"role": "assistant", "content": "MATCH (fam:Famiglia)<-[:INCLUSA_IN]-(:Sottofamiglia)<-[:APPARTIENE_A]-(:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_RICEVUTO]-(c:Cliente) WHERE dr.tipoValore = 'Bollato' AND dr.importo > 0 WITH fam, c, sum(dr.importo) AS fatturato ORDER BY fam.nome, fatturato DESC WITH fam, collect({cliente: c.name, fatturato: fatturato}) AS clientiOrdinati RETURN fam.nome AS famiglia, clientiOrdinati[0].cliente AS topCliente, clientiOrdinati[0].fatturato AS fatturatoMassimo"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto COMPR.ASPERA NJ2212GK?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'compr.aspera nj2212gk' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho speso per acquistare il prodotto UNITA' ERMETICA UT6220GK?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'unita' ermetica ut6220gk' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Calcola il rapporto tra costo totale e fatturato totale per il prodotto 'COMPR.FRASCOLD A 0.75Y'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.frascold a 0.75y' OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_acq:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WITH a, sum(dr_acq.importo) AS costoTotale OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_ven:RigaDocumento {tipoValore: 'Fatturato'})<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_RICEVUTO]-(:Cliente) WHERE dr_ven.importo > 0 WITH costoTotale, sum(dr_ven.importo) AS fatturatoTotale RETURN costoTotale, fatturatoTotale, (fatturatoTotale / costoTotale) AS rapporto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quali ditte vendono prodotti della famiglia 'VALVOLE'?"}, {"role": "assistant", "content": "MATCH (d:Ditta)<-[:APPARTIENE_A]-(:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)-[:INCLUSA_IN]->(fam:Famiglia) WHERE toLower(trim(fam.nome)) = 'valvole' RETURN DISTINCT d.dittaId AS ditta ORDER BY ditta"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il margine di profitto del prodotto 'UNITA' COND.ERMET. TEAC NB6152GK'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr1:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' cond.ermet. teac nb6152gk' AND dr1.tipoValore = 'Fatturato' AND dr1.importo > 0 WITH a, sum(dr1.importo) AS fatturato MATCH (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WITH a, fatturato, sum(dr2.importo) AS costo RETURN a.descrizione AS prodotto, fatturato, costo, (fatturato - costo) AS margine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto COMPR.ASPERA J6226Z?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'compr.aspera j6226z' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Attualmente la ditta 2 è in perdita o in crescita?"}, {"role": "assistant", "content": "MATCH (d:Ditta {dittaId: '2'})<-[:APPARTIENE_A]-(:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE dr.tipoValore = 'Bollato' AND dr.importo > 0 AND doc.dataEmissione.year IN [date().year, date().year - 1] RETURN doc.dataEmissione.year AS anno, sum(dr.importo) AS fatturatoAnnuale ORDER BY anno DESC"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Trova i fornitori che non ci hanno mai venduto prodotti della famiglia 'TERMOSTATI'"}, {"role": "assistant", "content": "MATCH (fam:Famiglia) WHERE toLower(trim(fam.nome)) = 'termostati' WITH fam MATCH (gf:GruppoFornitore) WHERE NOT (gf)<-[:RAGGRUPPATO_SOTTO]-(:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)-[:INCLUSA_IN]->(fam) RETURN gf.ragioneSociale AS fornitore"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca i fornitori situati in un luogo dove non abbiamo clienti."}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HAS_ADDRESS]->(l:Luogo) WITH collect(DISTINCT l.localita) AS localitaClienti MATCH (f:Fornitore)-[:SI_TROVA_A]->(lf:Luogo) WHERE NOT lf.localita IN localitaClienti MATCH (f)-[:RAGGRUPPATO_SOTTO]->(gf:GruppoFornitore) RETURN DISTINCT gf.ragioneSociale AS fornitoreIsolato"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'COMPR.MANEUROP MTZ40JH R404'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.maneurop mtz40jh r404' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è la località con il maggior numero di fornitori?"}, {"role": "assistant", "content": "MATCH (f:Fornitore)-[:SI_TROVA_A]->(l:Luogo) WHERE l.localita IS NOT NULL RETURN l.localita AS localita, count(DISTINCT f) AS numeroFornitori ORDER BY numeroFornitori DESC LIMIT 1"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'COMPR.ASPERA NB6152GK'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera nb6152gk' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Mostrami 10 documenti di tipo 'FVC' emessi a Gennaio 2025 al cliente 'SIEC SRL'"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:IS_TYPE]->(dt:DocType) WHERE toLower(trim(c.name)) = 'siec srl' AND dt.codice = 'FVC' AND doc.dataEmissione.year = 2025 AND doc.dataEmissione.month = 1 RETURN doc.documentoinstruction AS documento LIMIT 10"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Calcola il rapporto tra costo totale e fatturato totale per il prodotto 'UNITA' ASPERA UE9213GK'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' aspera ue9213gk' OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_acq:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WITH a, sum(dr_acq.importo) AS costoTotale OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_ven:RigaDocumento {tipoValore: 'Fatturato'})<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_RICEVUTO]-(:Cliente) WHERE dr_ven.importo > 0 WITH costoTotale, sum(dr_ven.importo) AS fatturatoTotale RETURN costoTotale, fatturatoTotale, (fatturatoTotale / costoTotale) AS rapporto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto UC98Z-D 2.13Y UNITA' SEM.FRASCOLD?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'uc98z-d 2.13y unita' sem.frascold' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho speso per acquistare il prodotto COMPR.BITZER 4TC82Y40?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'compr.bitzer 4tc82y40' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il fatturato totale del cliente L'ABBONDANZA SRL?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE toLower(trim(c.name)) = 'l'abbondanza srl' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS fatturatoTotale"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto UNITA' CONDENSATRICE TUC HG 150 A/2?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'unita' condensatrice tuc hg 150 a/2' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'F 4.19Y COMPRESSORE FRASCOLD'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'f 4.19y compressore frascold' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'NJ2212GS R404 ASPERA'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'nj2212gs r404 aspera' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'COMPE.ELECTROLUX GL80TB'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compe.electrolux gl80tb' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il fatturato del primo trimestre 2025?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0 AND doc.dataEmissione.year = 2025 AND doc.dataEmissione.month >= 1 AND doc.dataEmissione.month <= 3 RETURN sum(dr.importo) AS fatturatoTrimestre"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Calcola il fatturato totale per il secondo trimestre del 2024 (aprile, maggio, giugno)."}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0 AND doc.dataEmissione.year = 2024 AND doc.dataEmissione.month IN [4, 5, 6] RETURN sum(dr.importo) AS fatturatoTrimestre"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Calcola il rapporto tra costo totale e fatturato totale per il prodotto 'KIT GUAR.TALLONE MAGN.C/MAG.20'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'kit guar.tallone magn.c/mag.20' OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_acq:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WITH a, sum(dr_acq.importo) AS costoTotale OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_ven:RigaDocumento {tipoValore: 'Fatturato'})<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_RICEVUTO]-(:Cliente) WHERE dr_ven.importo > 0 WITH costoTotale, sum(dr_ven.importo) AS fatturatoTotale RETURN costoTotale, fatturatoTotale, (fatturatoTotale / costoTotale) AS rapporto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto COMPRESSORE ASPERA NJ2192GK?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compressore aspera nj2192gk' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Mostrami i clienti il cui primo documento di vendita è stato emesso negli ultimi 6 mesi."}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(doc:Documento) WITH c, min(doc.dataEmissione) AS primoAcquisto WHERE primoAcquisto >= date() - duration({months: 6}) RETURN c.name AS clienteRecente, primoAcquisto ORDER BY primoAcquisto DESC"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto NJ2212GS R404 ASPERA?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'nj2212gs r404 aspera' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto CANALE CHIUSO 200 X 80?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'canale chiuso 200 x 80' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca le sottofamiglie della famiglia 'CENTRALI FRIGO'"}, {"role": "assistant", "content": "MATCH (f:Famiglia)<-[:INCLUSA_IN]-(sf:Sottofamiglia) WHERE toLower(trim(f.nome)) = 'centrali frigo' RETURN DISTINCT sf.nome AS sottofamiglia ORDER BY sottofamiglia"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Mostrami 10 documenti di tipo 'FVC' emessi a Gennaio 2025 al cliente 'GANZ EINFACH GMBH'"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:IS_TYPE]->(dt:DocType) WHERE toLower(trim(c.name)) = 'ganz einfach gmbh' AND dt.codice = 'FVC' AND doc.dataEmissione.year = 2025 AND doc.dataEmissione.month = 1 RETURN doc.documentoinstruction AS documento LIMIT 10"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'UNITA' CONDENSATRICE'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' condensatrice' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il margine di profitto del prodotto 'COMPR.ASPERA NE 6181 ECSIR'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr1:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera ne 6181 ecsir' AND dr1.tipoValore = 'Fatturato' AND dr1.importo > 0 WITH a, sum(dr1.importo) AS fatturato MATCH (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WITH a, fatturato, sum(dr2.importo) AS costo RETURN a.descrizione AS prodotto, fatturato, costo, (fatturato - costo) AS margine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 prodotti che abbiamo venduto ma mai acquistato"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE NOT EXISTS { MATCH (a)<-[:RIGUARDA_ARTICOLO]-(:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) } RETURN DISTINCT a.descrizione AS prodotto ORDER BY prodotto LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quali sono i 3 prodotti più venduti al cliente 'MUNTEANU CONSANTINESPRINET SPA'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(c.name)) = 'munteanu consantinesprinet spa' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN a.descrizione AS prodotto, sum(dr.importo) AS totaleVenduto ORDER BY totaleVenduto DESC LIMIT 3"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Calcola il rapporto tra costo totale e fatturato totale per il prodotto 'DATO_NON_DISPONIBILE'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'dato_non_disponibile' OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_acq:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WITH a, sum(dr_acq.importo) AS costoTotale OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_ven:RigaDocumento {tipoValore: 'Fatturato'})<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_RICEVUTO]-(:Cliente) WHERE dr_ven.importo > 0 WITH costoTotale, sum(dr_ven.importo) AS fatturatoTotale RETURN costoTotale, fatturatoTotale, (fatturatoTotale / costoTotale) AS rapporto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quale fornitore ci ha inviato più documenti?"}, {"role": "assistant", "content": "MATCH (f:Fornitore)-[:HA_EMESSO]->(doc:Documento) RETURN f.ragioneSociale AS fornitore, count(doc) AS numeroDocumenti ORDER BY numeroDocumenti DESC LIMIT 1"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho speso per acquistare il prodotto CORDICELLA MM.10?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'cordicella mm.10' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Calcola il rapporto tra costo totale e fatturato totale per il prodotto 'COMPR.ASPERA NEK 6213 GK'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera nek 6213 gk' OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_acq:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WITH a, sum(dr_acq.importo) AS costoTotale OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_ven:RigaDocumento {tipoValore: 'Fatturato'})<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_RICEVUTO]-(:Cliente) WHERE dr_ven.importo > 0 WITH costoTotale, sum(dr_ven.importo) AS fatturatoTotale RETURN costoTotale, fatturatoTotale, (fatturatoTotale / costoTotale) AS rapporto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quali fornitori ci forniscono prodotti venduti al cliente 'ZYXEL NETWORKS A/S'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(c.name)) = 'zyxel networks a/s' WITH collect(DISTINCT a) AS articoliVenduti MATCH (gf:GruppoFornitore)<-[:RAGGRUPPATO_SOTTO]-(:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WHERE a IN articoliVenduti RETURN DISTINCT gf.ragioneSociale AS fornitore ORDER BY fornitore"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'BACINELLA IN RAME'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'bacinella in rame' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto ML80TB R404A COMPR. ELEKTROLUX?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'ml80tb r404a compr. elektrolux' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Mostrami i documenti di tipo 'FVC' emessi a gennaio 2025 per il cliente 'MUNTEANU CONSTANTIN'"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:IS_TYPE]->(dt:DocType) WHERE toLower(trim(c.name)) = 'munteanu constantin' AND dt.codice = 'FVC' AND doc.dataEmissione.year = 2025 AND doc.dataEmissione.month = 1 RETURN doc.documentoinstruction AS documento"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Trova il cliente con il valore medio degli ordini più alto."}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE dr.tipoValore = 'Ordinato' AND dr.importo > 0 WITH c, doc, sum(dr.importo) AS valoreOrdine RETURN c.name AS cliente, avg(valoreOrdine) AS valoreMedioOrdine ORDER BY valoreMedioOrdine DESC LIMIT 1"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto UNITA' ASPERA UE9213GK?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' aspera ue9213gk' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Trova i prodotti in comune venduti all'azienda '1' e acquistati dal fornitore 'FORNITORE ESEMPIO SPA'."}, {"role": "assistant", "content": "MATCH (d:Ditta {dittaId: '1'})<-[:APPARTIENE_A]-(:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WITH collect(DISTINCT a) AS prodottiVenduti MATCH (gf:GruppoFornitore)<-[:RAGGRUPPATO_SOTTO]-(:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a2:Articolo) WHERE toLower(trim(gf.ragioneSociale)) = 'fornitore esempio spa' AND a2 IN prodottiVenduti RETURN a2.descrizione AS prodottoComune"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto FABBRICATORE SG600 AW R.01?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'fabbricatore sg600 aw r.01' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto UNIITA' COND.SERMIERM.UTFA 2B210.1 Y-LLD?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'uniita' cond.sermierm.utfa 2b210.1 y-lld' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho speso per acquistare il prodotto COMPRESSORE ELECTROLUX MX18FB?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'compressore electrolux mx18fb' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Calcola il rapporto tra costo totale e fatturato totale per il prodotto 'COMPRESSORE ASPERA NJ9238GK'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compressore aspera nj9238gk' OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_acq:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WITH a, sum(dr_acq.importo) AS costoTotale OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_ven:RigaDocumento {tipoValore: 'Fatturato'})<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_RICEVUTO]-(:Cliente) WHERE dr_ven.importo > 0 WITH costoTotale, sum(dr_ven.importo) AS fatturatoTotale RETURN costoTotale, fatturatoTotale, (fatturatoTotale / costoTotale) AS rapporto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto UNIITA' COND.SERMIERM.UTFA 2B210.1 Y-LLD?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'uniita' cond.sermierm.utfa 2b210.1 y-lld' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho speso per acquistare il prodotto NJ2212GS R404 ASPERA?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'nj2212gs r404 aspera' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'COMPR.ASPERA T2134Z'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera t2134z' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho speso per acquistare il prodotto FABBRICATORE DI GHIACCIO S550W?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'fabbricatore di ghiaccio s550w' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho speso per acquistare il prodotto COMPRESSORE ASPERA J9226P?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'compressore aspera j9226p' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto TENDINA MAN T FOR L2500?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'tendina man t for l2500' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto CENTRALINA DISTRIBUZIONE?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'centralina distribuzione' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'COMPR.ASPERA NEK 6213 GK'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera nek 6213 gk' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il margine di profitto del prodotto 'COMPRESSORE ELECTROLUX L57TN'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr1:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compressore electrolux l57tn' AND dr1.tipoValore = 'Fatturato' AND dr1.importo > 0 WITH a, sum(dr1.importo) AS fatturato MATCH (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WITH a, fatturato, sum(dr2.importo) AS costo RETURN a.descrizione AS prodotto, fatturato, costo, (fatturato - costo) AS margine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto KIT GUAR.TALLONE MAGN.C/MAG.20?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'kit guar.tallone magn.c/mag.20' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Mostrami 10 documenti di tipo 'FVC' emessi a Gennaio 2025 al cliente 'AMAZON EU S.A.R.L. 6'"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:IS_TYPE]->(dt:DocType) WHERE toLower(trim(c.name)) = 'amazon eu s.a.r.l. 6' AND dt.codice = 'FVC' AND doc.dataEmissione.year = 2025 AND doc.dataEmissione.month = 1 RETURN doc.documentoinstruction AS documento LIMIT 10"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il margine di profitto del prodotto 'COMPR.ASPERA NJ9232GK'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr1:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera nj9232gk' AND dr1.tipoValore = 'Fatturato' AND dr1.importo > 0 WITH a, sum(dr1.importo) AS fatturato MATCH (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WITH a, fatturato, sum(dr2.importo) AS costo RETURN a.descrizione AS prodotto, fatturato, costo, (fatturato - costo) AS margine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "L'azienda 2 sta attualmente perdendo o crescendo?"}, {"role": "assistant", "content": "MATCH (d:Ditta {dittaId: '2'})<-[:APPARTIENE_A]-(:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE dr.tipoValore = 'Bollato' AND dr.importo > 0 AND doc.dataEmissione.year IN [date().year, date().year - 1] RETURN doc.dataEmissione.year AS anno, sum(dr.importo) AS fatturatoAnnuale ORDER BY anno DESC"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il fatturato totale del cliente AMAZON EU S.A.R.L. 6?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE toLower(trim(c.name)) = 'amazon eu s.a.r.l. 6' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS fatturatoTotale"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho speso per acquistare il prodotto UNITA' ARIA SEMIERM.UTFA 2A0.75Y?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'unita' aria semierm.utfa 2a0.75y' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il margine di profitto del prodotto 'COMPRESSORE ASPERA J7240FPSC'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr1:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compressore aspera j7240fpsc' AND dr1.tipoValore = 'Fatturato' AND dr1.importo > 0 WITH a, sum(dr1.importo) AS fatturato MATCH (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WITH a, fatturato, sum(dr2.importo) AS costo RETURN a.descrizione AS prodotto, fatturato, costo, (fatturato - costo) AS margine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il margine di profitto del prodotto 'FABBRICATORE GHIACCIO S550 A'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr1:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'fabbricatore ghiaccio s550 a' AND dr1.tipoValore = 'Fatturato' AND dr1.importo > 0 WITH a, sum(dr1.importo) AS fatturato MATCH (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WITH a, fatturato, sum(dr2.importo) AS costo RETURN a.descrizione AS prodotto, fatturato, costo, (fatturato - costo) AS margine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto COMPE.ELECTROLUX GL80TB?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compe.electrolux gl80tb' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto COMPRESSORE ASPERA NJ2192GK?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'compressore aspera nj2192gk' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Calcola il rapporto tra costo totale e fatturato totale per il prodotto 'FABBRICATORE DI GHIACCIO SB90A'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'fabbricatore di ghiaccio sb90a' OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_acq:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WITH a, sum(dr_acq.importo) AS costoTotale OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_ven:RigaDocumento {tipoValore: 'Fatturato'})<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_RICEVUTO]-(:Cliente) WHERE dr_ven.importo > 0 WITH costoTotale, sum(dr_ven.importo) AS fatturatoTotale RETURN costoTotale, fatturatoTotale, (fatturatoTotale / costoTotale) AS rapporto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 50 clienti situati a Perugia"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HAS_ADDRESS]->(l:Luogo) WHERE toLower(trim(l.localita)) = 'perugia' RETURN DISTINCT c.name AS cliente ORDER BY cliente LIMIT 50"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho speso per acquistare il prodotto UNITA' COND.UTFA2B1,59.Y?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'unita' cond.utfa2b1,59.y' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho speso per acquistare il prodotto COMPR.ASPERA NJ9238GS?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'compr.aspera nj9238gs' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il fatturato totale del cliente ROSSI SPA?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE toLower(trim(c.name)) = 'rossi spa' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS fatturatoTotale"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il margine di profitto del prodotto 'UNITA' ERMETICA UT6220GK'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr1:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' ermetica ut6220gk' AND dr1.tipoValore = 'Fatturato' AND dr1.importo > 0 WITH a, sum(dr1.importo) AS fatturato MATCH (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WITH a, fatturato, sum(dr2.importo) AS costo RETURN a.descrizione AS prodotto, fatturato, costo, (fatturato - costo) AS margine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto KIT GUAR.TALLONE MAGN.C/MAG.20?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'kit guar.tallone magn.c/mag.20' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto UNITA' COND.ERMET.TEAV NEK6181GK?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'unita' cond.ermet.teav nek6181gk' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto FABBRICATORE DI GHIACCIO MOD.S350W?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'fabbricatore di ghiaccio mod.s350w' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto RESISTENZA ANTICONDENSA 48V 18W CELLA?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'resistenza anticondensa 48v 18w cella' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il fatturato totale del cliente VERDI COSTRUZIONI?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE toLower(trim(c.name)) = 'verdi costruzioni' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS fatturatoTotale"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto COMPR.ASPERA NB6165 GK?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera nb6165 gk' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Per i primi 3 clienti per fatturato, mostra il loro prodotto più acquistato per valore."}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0 WITH c, sum(dr.importo) AS fatturatoTotale ORDER BY fatturatoTotale DESC LIMIT 3 MATCH (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE dr2.tipoValore = 'Fatturato' AND dr2.importo > 0 WITH c, a, sum(dr2.importo) AS valoreProdotto ORDER BY c.name, valoreProdotto DESC WITH c, collect({prodotto: a.descrizione, valore: valoreProdotto})[0] AS prodottoTop RETURN c.name AS cliente, prodottoTop.prodotto AS prodottoPiuAcquistato, prodottoTop.valore"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Trova il cliente con il valore medio degli ordini più alto."}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0 WITH c, doc, sum(dr.importo) AS valoreOrdine RETURN c.name AS cliente, avg(valoreOrdine) AS valoreMedioOrdine ORDER BY valoreMedioOrdine DESC LIMIT 1"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'UNITA' CARENATA UTFACA D 11.1'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' carenata utfaca d 11.1' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quali ditte vendono prodotti della famiglia 'INTERRUTTORI'?"}, {"role": "assistant", "content": "MATCH (d:Ditta)<-[:APPARTIENE_A]-(:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)-[:INCLUSA_IN]->(fam:Famiglia) WHERE toLower(trim(fam.nome)) = 'interruttori' RETURN DISTINCT d.dittaId AS ditta ORDER BY ditta"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho speso per acquistare il prodotto SG350A FABBRICATORE DI GHIACCIO?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'sg350a fabbricatore di ghiaccio' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Trova i fornitori che non ci hanno mai venduto prodotti della famiglia 'BACINELLA'"}, {"role": "assistant", "content": "MATCH (fam:Famiglia) WHERE toLower(trim(fam.nome)) = 'bacinella' WITH fam MATCH (gf:GruppoFornitore) WHERE NOT (gf)<-[:RAGGRUPPATO_SOTTO]-(:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)-[:INCLUSA_IN]->(fam) RETURN gf.ragioneSociale AS fornitore"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto COMPR.ASPERA NB6152GK?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera nb6152gk' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho speso per acquistare il prodotto FABBRICATORE DI GHIACCIO MOD.S350W?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'fabbricatore di ghiaccio mod.s350w' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Mostrami 10 documenti di tipo 'FVC' emessi a Gennaio 2025 al cliente 'STARLINK INTERNET SERVICES LIMITED'"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:IS_TYPE]->(dt:DocType) WHERE toLower(trim(c.name)) = 'starlink internet services limited' AND dt.codice = 'FVC' AND doc.dataEmissione.year = 2025 AND doc.dataEmissione.month = 1 RETURN doc.documentoinstruction AS documento LIMIT 10"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho speso per acquistare il prodotto UNITAA' COND.ERTM.TEAV NE6187Z?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'unitaa' cond.ertm.teav ne6187z' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto FABBRICATORE DI GHIACCIO SB90A?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'fabbricatore di ghiaccio sb90a' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto UNITA' COND.ERM.TEAV J9226GK?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' cond.erm.teav j9226gk' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto UNITA' CARENATA UTFACA D 11.1?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' carenata utfaca d 11.1' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è la famiglia di prodotti più acquistata?"}, {"role": "assistant", "content": "MATCH (:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo)-[:APPARTIENE_A]->(sf:Sottofamiglia)-[:INCLUSA_IN]->(fam:Famiglia) RETURN fam.nome AS famiglia, sum(dr.quantita) AS quantitaTotale ORDER BY quantitaTotale DESC LIMIT 1"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto COMPR.UN.HERMETIQUE TFH S524 E?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'compr.un.hermetique tfh s524 e' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'DIVISORIO IN FILO USATO 50X9'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'divisorio in filo usato 50x9' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Mostrami tutti gli ordini fornitori (OF) per maggio 2025."}, {"role": "assistant", "content": "MATCH (doc:Documento)-[:IS_TYPE]->(dt:DocType {codice: 'OF'}) WHERE doc.dataEmissione.year = 2025 AND doc.dataEmissione.month = 5 RETURN doc.documentoinstruction AS ordine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto DATO_NON_DISPONIBILE?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'dato_non_disponibile' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il margine di profitto del prodotto 'UNITA' COND.ERMET.TEAV2 T6220GK'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr1:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' cond.ermet.teav2 t6220gk' AND dr1.tipoValore = 'Fatturato' AND dr1.importo > 0 WITH a, sum(dr1.importo) AS fatturato MATCH (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WITH a, fatturato, sum(dr2.importo) AS costo RETURN a.descrizione AS prodotto, fatturato, costo, (fatturato - costo) AS margine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto COMPRESSORE NJ6220Z?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compressore nj6220z' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Mostrami i documenti di tipo 'FVC' emessi a gennaio 2025 per il cliente 'ARISTON SNC'"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:IS_TYPE]->(dt:DocType) WHERE toLower(trim(c.name)) = 'ariston snc' AND dt.codice = 'FVC' AND doc.dataEmissione.year = 2025 AND doc.dataEmissione.month = 1 RETURN doc.documentoinstruction AS documento"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quali ditte vendono prodotti della famiglia 'CRISTALLI SAGOMATI'?"}, {"role": "assistant", "content": "MATCH (d:Ditta)<-[:APPARTIENE_A]-(:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)-[:INCLUSA_IN]->(fam:Famiglia) WHERE toLower(trim(fam.nome)) = 'cristalli sagomati' RETURN DISTINCT d.dittaId AS ditta ORDER BY ditta"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto UNITA' COND.ERM.TEAV J9226GK?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'unita' cond.erm.teav j9226gk' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto UNITA' CARENATA UTFACALC 2 B 1,59.1Y-LLD?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'unita' carenata utfacalc 2 b 1,59.1y-lld' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto COMPR.UNITE' HERMETIQUE?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.unite' hermetique' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'COMPR.ELECTROLUX MS26TB'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.electrolux ms26tb' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho speso per acquistare il prodotto COMPR.ASPERA UJ9226GK-02?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'compr.aspera uj9226gk-02' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quali aziende vendono prodotti della famiglia 'FRONTALE'?"}, {"role": "assistant", "content": "MATCH (d:Ditta)<-[:APPARTIENE_A]-(:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)-[:INCLUSA_IN]->(fam:Famiglia) WHERE toLower(trim(fam.nome)) = 'frontale' RETURN DISTINCT d.dittaId AS ditta ORDER BY ditta"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Mostrami 10 documenti di tipo 'FVC' emessi a Gennaio 2025 al cliente 'MUNTEANU CONSTANTIN'"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:IS_TYPE]->(dt:DocType) WHERE toLower(trim(c.name)) = 'munteanu constantin' AND dt.codice = 'FVC' AND doc.dataEmissione.year = 2025 AND doc.dataEmissione.month = 1 RETURN doc.documentoinstruction AS documento LIMIT 10"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il fatturato tra Gennaio 2023 e Marzo 2023?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0 AND doc.dataEmissione >= date('2023-01-01') AND doc.dataEmissione <= date('2023-03-31') RETURN sum(dr.importo) AS fatturatoPeriodo"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il margine di profitto del prodotto 'COMPR.ASPERA T2134Z'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr1:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera t2134z' AND dr1.tipoValore = 'Fatturato' AND dr1.importo > 0 WITH a, sum(dr1.importo) AS fatturato MATCH (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WITH a, fatturato, sum(dr2.importo) AS costo RETURN a.descrizione AS prodotto, fatturato, costo, (fatturato - costo) AS margine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'GUARNIZIONE PER PORTA'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'guarnizione per porta' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto COMPR.ASPERA NJ9232GK?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera nj9232gk' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Chi è il cliente con il valore fatturato più alto considerando solo le fatture immediate (FVC)?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:IS_TYPE]->(dt:DocType {codice: 'FVC'}) MATCH (doc)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN c.name AS cliente, sum(dr.importo) AS totale ORDER BY totale DESC LIMIT 1"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho speso per acquistare il prodotto RESISTENZA ANTICONDENSA 48V 18W CELLA?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'resistenza anticondensa 48v 18w cella' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il margine di profitto del prodotto 'COMPR.UN.HERMETIQUE TFH S524 E'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr1:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.un.hermetique tfh s524 e' AND dr1.tipoValore = 'Fatturato' AND dr1.importo > 0 WITH a, sum(dr1.importo) AS fatturato MATCH (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WITH a, fatturato, sum(dr2.importo) AS costo RETURN a.descrizione AS prodotto, fatturato, costo, (fatturato - costo) AS margine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quali fornitori ci forniscono prodotti venduti al cliente 'CONSORZIO REAL CLEAN GROUP'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(c.name)) = 'consorzio real clean group' WITH collect(DISTINCT a) AS articoliVenduti MATCH (gf:GruppoFornitore)<-[:RAGGRUPPATO_SOTTO]-(:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WHERE a IN articoliVenduti RETURN DISTINCT gf.ragioneSociale AS fornitore ORDER BY fornitore"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Mostrami 3 prodotti che abbiamo acquistato ma mai venduto."}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WITH DISTINCT a WHERE NOT (a)<-[:RIGUARDA_ARTICOLO]-(:RigaDocumento {tipoValore: 'Fatturato'}) RETURN a.descrizione AS prodottoMaiVenduto LIMIT 3"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto COMPR.ASPERA T2168E?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'compr.aspera t2168e' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto COMPR.U.H.TAG4561Z?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.u.h.tag4561z' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho speso per acquistare il prodotto COMPRESSORE ASPERA T6220GK?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'compressore aspera t6220gk' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quali sono i 3 prodotti più venduti al cliente 'AMAZON EU S.A.R.L. 6'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(c.name)) = 'amazon eu s.a.r.l. 6' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN a.descrizione AS prodotto, sum(dr.importo) AS totaleVenduto ORDER BY totaleVenduto DESC LIMIT 3"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Chi sono i 50 clienti con il fatturato più basso?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN c.name AS cliente, sum(dr.importo) AS fatturatoTotale ORDER BY fatturatoTotale ASC LIMIT 50"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quali sono i 3 prodotti più venduti al cliente 'ICE CONTROL SRL'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(c.name)) = 'ice control srl' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN a.descrizione AS prodotto, sum(dr.importo) AS totaleVenduto ORDER BY totaleVenduto DESC LIMIT 3"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto COMPR.ASPERA NE6210GK?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'compr.aspera ne6210gk' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto COMPR.ASPERA NB6165GK?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera nb6165gk' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto FABBRICATORE TIPO SG230A?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'fabbricatore tipo sg230a' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Mostrami i documenti di tipo 'FVC' emessi a gennaio 2025 per il cliente 'GRUPPO CB SRL'"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:IS_TYPE]->(dt:DocType) WHERE toLower(trim(c.name)) = 'gruppo cb srl' AND dt.codice = 'FVC' AND doc.dataEmissione.year = 2025 AND doc.dataEmissione.month = 1 RETURN doc.documentoinstruction AS documento"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'COMPR.UNITE' HERMETIQUE'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.unite' hermetique' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'UNITA' COND.ERMET.TEAV2 T6220GK'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' cond.ermet.teav2 t6220gk' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che si trovano a Perugia"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HAS_ADDRESS]->(l:Luogo) WHERE toLower(trim(l.localita)) = 'perugia' RETURN DISTINCT c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho speso per acquistare il prodotto UTFA 2 D 2.13.1 Y-LLD UNITA' SEMIERM?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'utfa 2 d 2.13.1 y-lld unita' semierm' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quali aziende vendono prodotti della famiglia 'ARMAFLEX'?"}, {"role": "assistant", "content": "MATCH (d:Ditta)<-[:APPARTIENE_A]-(:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)-[:INCLUSA_IN]->(fam:Famiglia) WHERE toLower(trim(fam.nome)) = 'armaflex' RETURN DISTINCT d.dittaId AS ditta ORDER BY ditta"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il fatturato totale del cliente ARCADIA CAFFE' SNC?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE toLower(trim(c.name)) = 'arcadia caffe' snc' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS fatturatoTotale"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Mostrami la crescita del fatturato mese su mese per l'anno 2024."}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0 AND doc.dataEmissione.year = 2024 WITH doc.dataEmissione.month AS mese, sum(dr.importo) AS fatturatoMensile ORDER BY mese WITH collect(fatturatoMensile) AS fatturati RETURN [i in range(0, size(fatturati)-2) | (fatturati[i+1] - fatturati[i]) / fatturati[i] * 100] AS crescitaPercentualeMeseSuMese"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Calcola il rapporto tra costo totale e fatturato totale per il prodotto 'UNITA' CARENATA UTFACA D 313.1Y'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' carenata utfaca d 313.1y' OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_acq:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WITH a, sum(dr_acq.importo) AS costoTotale OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_ven:RigaDocumento {tipoValore: 'Fatturato'})<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_RICEVUTO]-(:Cliente) WHERE dr_ven.importo > 0 WITH costoTotale, sum(dr_ven.importo) AS fatturatoTotale RETURN costoTotale, fatturatoTotale, (fatturatoTotale / costoTotale) AS rapporto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il fatturato totale del cliente BARONE DI FERRANTE EZIO?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE toLower(trim(c.name)) = 'barone di ferrante ezio' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS fatturatoTotale"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Calcola il rapporto tra costo totale e fatturato totale per il prodotto 'COMPR.ASPERA NE2134GK'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera ne2134gk' OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_acq:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WITH a, sum(dr_acq.importo) AS costoTotale OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_ven:RigaDocumento {tipoValore: 'Fatturato'})<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_RICEVUTO]-(:Cliente) WHERE dr_ven.importo > 0 WITH costoTotale, sum(dr_ven.importo) AS fatturatoTotale RETURN costoTotale, fatturatoTotale, (fatturatoTotale / costoTotale) AS rapporto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Calcola il rapporto tra costo totale e fatturato totale per il prodotto 'COMPRESSORE ASPERA NJ9226GS'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compressore aspera nj9226gs' OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_acq:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WITH a, sum(dr_acq.importo) AS costoTotale OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_ven:RigaDocumento {tipoValore: 'Fatturato'})<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_RICEVUTO]-(:Cliente) WHERE dr_ven.importo > 0 WITH costoTotale, sum(dr_ven.importo) AS fatturatoTotale RETURN costoTotale, fatturatoTotale, (fatturatoTotale / costoTotale) AS rapporto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto COMPR.MANEUROP SZ 84 4VI 380V R407?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'compr.maneurop sz 84 4vi 380v r407' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'UNITA' ARIA SEMIER.UTFA 2A 1.5 7Y'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' aria semier.utfa 2a 1.5 7y' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto UNITA' SEM.FRASCOLD UC58-A 0.75Y?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' sem.frascold uc58-a 0.75y' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Calcola il rapporto tra costo totale e fatturato totale per il prodotto 'COMPRESSORE ASPERA NB2118Z'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compressore aspera nb2118z' OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_acq:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WITH a, sum(dr_acq.importo) AS costoTotale OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_ven:RigaDocumento {tipoValore: 'Fatturato'})<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_RICEVUTO]-(:Cliente) WHERE dr_ven.importo > 0 WITH costoTotale, sum(dr_ven.importo) AS fatturatoTotale RETURN costoTotale, fatturatoTotale, (fatturatoTotale / costoTotale) AS rapporto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il margine di profitto del prodotto 'FABBRICATORE DI GHIACCIO MOD.S350W'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr1:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'fabbricatore di ghiaccio mod.s350w' AND dr1.tipoValore = 'Fatturato' AND dr1.importo > 0 WITH a, sum(dr1.importo) AS fatturato MATCH (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WITH a, fatturato, sum(dr2.importo) AS costo RETURN a.descrizione AS prodotto, fatturato, costo, (fatturato - costo) AS margine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il margine di profitto del prodotto 'COMPRESSORE MX21TB'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr1:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compressore mx21tb' AND dr1.tipoValore = 'Fatturato' AND dr1.importo > 0 WITH a, sum(dr1.importo) AS fatturato MATCH (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WITH a, fatturato, sum(dr2.importo) AS costo RETURN a.descrizione AS prodotto, fatturato, costo, (fatturato - costo) AS margine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto COMPR.ASPERA NE6187Z?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera ne6187z' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Calcola il fatturato totale per il secondo trimestre del 2023 (aprile, maggio, giugno)."}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0 AND doc.dataEmissione.year = 2023 AND doc.dataEmissione.month IN [4, 5, 6] RETURN sum(dr.importo) AS fatturatoTrimestre"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Chi è il cliente con il ordinato più alto?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE dr.tipoValore = 'Ordinato' AND dr.importo > 0 RETURN c.name AS cliente, sum(dr.importo) AS fatturatoTotale ORDER BY fatturatoTotale DESC LIMIT 1"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Mostrami i documenti di tipo 'FVC' emessi a gennaio 2025 per il cliente 'ANTONELLI FRIGO'"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:IS_TYPE]->(dt:DocType) WHERE toLower(trim(c.name)) = 'antonelli frigo' AND dt.codice = 'FVC' AND doc.dataEmissione.year = 2025 AND doc.dataEmissione.month = 1 RETURN doc.documentoinstruction AS documento"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho speso per acquistare il prodotto ML80TB R404A COMPR. ELEKTROLUX?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'ml80tb r404a compr. elektrolux' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto FABBRICATORE DI GHIACCIO MOD.S350W?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'fabbricatore di ghiaccio mod.s350w' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto UNITA' COND.ERMET.TEAV 2J2192GS?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' cond.ermet.teav 2j2192gs' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quali sono i 3 prodotti più venduti al cliente 'AZZURRA SNC'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(c.name)) = 'azzurra snc' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN a.descrizione AS prodotto, sum(dr.importo) AS totaleVenduto ORDER BY totaleVenduto DESC LIMIT 3"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il margine di profitto del prodotto 'COMPR.BITZER 4TC82Y40'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr1:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.bitzer 4tc82y40' AND dr1.tipoValore = 'Fatturato' AND dr1.importo > 0 WITH a, sum(dr1.importo) AS fatturato MATCH (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WITH a, fatturato, sum(dr2.importo) AS costo RETURN a.descrizione AS prodotto, fatturato, costo, (fatturato - costo) AS margine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto DATO_NON_DISPONIBILE?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'dato_non_disponibile' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca i clienti dell'azienda '1' situati nella provincia di 'NA'"}, {"role": "assistant", "content": "MATCH (d:Ditta {dittaId: '1'})<-[:APPARTIENE_A]-(c:Cliente)-[:HAS_ADDRESS]->(l:Luogo) WHERE toLower(trim(l.provincia)) = 'na' RETURN c.name AS cliente ORDER BY cliente"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto DIVISORIO VASCA 80X15H?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'divisorio vasca 80x15h' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il margine di profitto del prodotto 'UNITA' CARENATA SIL.UTFACS D 313.1Y'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr1:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' carenata sil.utfacs d 313.1y' AND dr1.tipoValore = 'Fatturato' AND dr1.importo > 0 WITH a, sum(dr1.importo) AS fatturato MATCH (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WITH a, fatturato, sum(dr2.importo) AS costo RETURN a.descrizione AS prodotto, fatturato, costo, (fatturato - costo) AS margine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Calcola il rapporto tra costo totale e fatturato totale per il prodotto 'COMPR.ELECTROLUX ML90FB'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.electrolux ml90fb' OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_acq:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WITH a, sum(dr_acq.importo) AS costoTotale OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_ven:RigaDocumento {tipoValore: 'Fatturato'})<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_RICEVUTO]-(:Cliente) WHERE dr_ven.importo > 0 WITH costoTotale, sum(dr_ven.importo) AS fatturatoTotale RETURN costoTotale, fatturatoTotale, (fatturatoTotale / costoTotale) AS rapporto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Calcola il rapporto tra costo totale e fatturato totale per il prodotto 'UNITA' COND.UTFA2B1,59.Y'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' cond.utfa2b1,59.y' OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_acq:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WITH a, sum(dr_acq.importo) AS costoTotale OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_ven:RigaDocumento {tipoValore: 'Fatturato'})<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_RICEVUTO]-(:Cliente) WHERE dr_ven.importo > 0 WITH costoTotale, sum(dr_ven.importo) AS fatturatoTotale RETURN costoTotale, fatturatoTotale, (fatturatoTotale / costoTotale) AS rapporto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il fatturato totale del cliente AZZURRA SNC?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE toLower(trim(c.name)) = 'azzurra snc' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS fatturatoTotale"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quante note di credito clienti (NCC) abbiamo emesso in totale?"}, {"role": "assistant", "content": "MATCH (doc:Documento)-[:IS_TYPE]->(dt:DocType {codice: 'NCC'}) RETURN count(doc) AS numeroNoteCredito"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Chi sono i principali fornitori degli articoli venduti al nostro miglior cliente?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE dr.tipoValore = 'Bollato' AND dr.importo > 0 WITH c, sum(dr.importo) AS fatturato ORDER BY fatturato DESC LIMIT 1 MATCH (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WITH collect(DISTINCT a) AS articoliTop MATCH (gf:GruppoFornitore)<-[:RAGGRUPPATO_SOTTO]-(:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a_check:Articolo) WHERE a_check IN articoliTop RETURN gf.ragioneSociale as fornitore, sum(dr.importo) AS valoreAcquistato ORDER BY valoreAcquistato DESC"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto COMPRESS.ASPERA T6220GK?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compress.aspera t6220gk' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Mostrami 10 documenti di tipo 'FVC' emessi a Gennaio 2025 al cliente 'SHEN ZHEN SHI HUA NUO SHI TING KE JI YOU XIAN GONG SI'"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:IS_TYPE]->(dt:DocType) WHERE toLower(trim(c.name)) = 'shen zhen shi hua nuo shi ting ke ji you xian gong si' AND dt.codice = 'FVC' AND doc.dataEmissione.year = 2025 AND doc.dataEmissione.month = 1 RETURN doc.documentoinstruction AS documento LIMIT 10"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Mostrami le ordini cliente per il cliente 'MUNTEANU CONSANTINESPRINET SPA'"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:IS_TYPE]->(dt:DocType) WHERE toLower(trim(c.name)) = 'munteanu consantinesprinet spa' AND dt.codice = 'OC' RETURN doc.documentoinstruction AS documento"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Mostrami tutti gli ordini fornitori (OF) per maggio 2021."}, {"role": "assistant", "content": "MATCH (doc:Documento)-[:IS_TYPE]->(dt:DocType {codice: 'OF'}) WHERE doc.dataEmissione.year = 2021 AND doc.dataEmissione.month = 5 RETURN doc.documentoinstruction AS ordine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Calcola il rapporto tra costo totale e fatturato totale per il prodotto 'FABBRICATORE GHIACCIO S550 A'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'fabbricatore ghiaccio s550 a' OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_acq:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WITH a, sum(dr_acq.importo) AS costoTotale OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_ven:RigaDocumento {tipoValore: 'Fatturato'})<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_RICEVUTO]-(:Cliente) WHERE dr_ven.importo > 0 WITH costoTotale, sum(dr_ven.importo) AS fatturatoTotale RETURN costoTotale, fatturatoTotale, (fatturatoTotale / costoTotale) AS rapporto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che si trovano a Milano"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HAS_ADDRESS]->(l:Luogo) WHERE toLower(trim(l.localita)) = 'milano' RETURN DISTINCT c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quale provincia ha generato il volume di bollato più alto?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HAS_ADDRESS]->(l:Luogo) MATCH (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE dr.tipoValore = 'Bollato' AND dr.importo > 0 RETURN l.provincia AS provincia, sum(dr.importo) AS fatturatoTotale ORDER BY fatturatoTotale DESC LIMIT 1"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto COMPR.ASPERA NB6165 GK?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'compr.aspera nb6165 gk' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho speso per acquistare il prodotto BACINELLA IN RAME?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'bacinella in rame' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto COMPR.MANEUROP SZ 84 4VI 380V R407?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.maneurop sz 84 4vi 380v r407' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Mostrami 10 documenti di tipo 'FVC' emessi a Gennaio 2025 al cliente 'L'ABBONDANZA SRL'"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:IS_TYPE]->(dt:DocType) WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl' AND dt.codice = 'FVC' AND doc.dataEmissione.year = 2025 AND doc.dataEmissione.month = 1 RETURN doc.documentoinstruction AS documento LIMIT 10"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il bollato tra Gennaio 2024 e Marzo 2024?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE dr.tipoValore = 'Bollato' AND dr.importo > 0 AND doc.dataEmissione >= date('2024-01-01') AND doc.dataEmissione <= date('2024-03-31') RETURN sum(dr.importo) AS fatturatoPeriodo"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 3 clienti che non hanno mai acquistato il prodotto 'GAS FREON SOLSTICE N40 R448A'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'gas freon solstice n40 r448a' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 3"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto COMPRESSORE ASPERA J9226P?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compressore aspera j9226p' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto COMPRESSORE ASPERA T6220GK?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compressore aspera t6220gk' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Calcola il rapporto tra costo totale e fatturato totale per il prodotto 'UNITA' ERMETICA UT6220GK'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' ermetica ut6220gk' OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_acq:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WITH a, sum(dr_acq.importo) AS costoTotale OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_ven:RigaDocumento {tipoValore: 'Fatturato'})<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_RICEVUTO]-(:Cliente) WHERE dr_ven.importo > 0 WITH costoTotale, sum(dr_ven.importo) AS fatturatoTotale RETURN costoTotale, fatturatoTotale, (fatturatoTotale / costoTotale) AS rapporto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il margine di profitto del prodotto 'COMPRESSORE ASPERA NB2118Z'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr1:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compressore aspera nb2118z' AND dr1.tipoValore = 'Fatturato' AND dr1.importo > 0 WITH a, sum(dr1.importo) AS fatturato MATCH (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WITH a, fatturato, sum(dr2.importo) AS costo RETURN a.descrizione AS prodotto, fatturato, costo, (fatturato - costo) AS margine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quali sono i 3 prodotti più venduti al cliente 'VINCENTI GATTI GIULIANO'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(c.name)) = 'vincenti gatti giuliano' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN a.descrizione AS prodotto, sum(dr.importo) AS totaleVenduto ORDER BY totaleVenduto DESC LIMIT 3"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il margine di profitto del prodotto 'COMPR.ASPERA NB6144Z'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr1:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera nb6144z' AND dr1.tipoValore = 'Fatturato' AND dr1.importo > 0 WITH a, sum(dr1.importo) AS fatturato MATCH (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WITH a, fatturato, sum(dr2.importo) AS costo RETURN a.descrizione AS prodotto, fatturato, costo, (fatturato - costo) AS margine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Calcola il rapporto tra costo totale e fatturato totale per il prodotto 'UNITA'COND.ERMET.TEAV2 J9238GK'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita'cond.ermet.teav2 j9238gk' OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_acq:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WITH a, sum(dr_acq.importo) AS costoTotale OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_ven:RigaDocumento {tipoValore: 'Fatturato'})<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_RICEVUTO]-(:Cliente) WHERE dr_ven.importo > 0 WITH costoTotale, sum(dr_ven.importo) AS fatturatoTotale RETURN costoTotale, fatturatoTotale, (fatturatoTotale / costoTotale) AS rapporto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto UNITA' SEM.FRASCOLD UC58-A 0.75Y?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' sem.frascold uc58-a 0.75y' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho speso per acquistare il prodotto COMPR-FRASCOLD D4D16Y?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'compr-frascold d4d16y' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho speso per acquistare il prodotto FABBRICATORE DI GHIACCIO SP702 AW?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'fabbricatore di ghiaccio sp702 aw' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto UTFA 2 D 2.13.1 Y-LLD UNITA' SEMIERM?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'utfa 2 d 2.13.1 y-lld unita' semierm' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho speso per acquistare il prodotto COMPRESSORE NT6220GK?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'compressore nt6220gk' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto FABBRICATORE DI GHIACCIO SP702 AW?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'fabbricatore di ghiaccio sp702 aw' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quali sono i 3 prodotti più venduti al cliente 'CHENGDU YUEHONGSHUN SHANGMAO YOUXIAN GONGSI'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(c.name)) = 'chengdu yuehongshun shangmao youxian gongsi' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN a.descrizione AS prodotto, sum(dr.importo) AS totaleVenduto ORDER BY totaleVenduto DESC LIMIT 3"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quali ditte vendono prodotti della famiglia 'EVAPORATORI'?"}, {"role": "assistant", "content": "MATCH (d:Ditta)<-[:APPARTIENE_A]-(:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)-[:INCLUSA_IN]->(fam:Famiglia) WHERE toLower(trim(fam.nome)) = 'evaporatori' RETURN DISTINCT d.dittaId AS ditta ORDER BY ditta"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quali aziende vendono prodotti della famiglia 'VALVOLE'?"}, {"role": "assistant", "content": "MATCH (d:Ditta)<-[:APPARTIENE_A]-(:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)-[:INCLUSA_IN]->(fam:Famiglia) WHERE toLower(trim(fam.nome)) = 'valvole' RETURN DISTINCT d.dittaId AS ditta ORDER BY ditta"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Trova i fornitori che non ci hanno mai venduto prodotti della famiglia 'GRUPPI FRIGO'"}, {"role": "assistant", "content": "MATCH (fam:Famiglia) WHERE toLower(trim(fam.nome)) = 'gruppi frigo' WITH fam MATCH (gf:GruppoFornitore) WHERE NOT (gf)<-[:RAGGRUPPATO_SOTTO]-(:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)-[:INCLUSA_IN]->(fam) RETURN gf.ragioneSociale AS fornitore"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto COMPR.ASPERA J6220GK?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'compr.aspera j6220gk' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Mostrami 10 documenti di tipo 'FVC' emessi a Gennaio 2025 al cliente 'CHIUCHINI GIANNI'"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:IS_TYPE]->(dt:DocType) WHERE toLower(trim(c.name)) = 'chiuchini gianni' AND dt.codice = 'FVC' AND doc.dataEmissione.year = 2025 AND doc.dataEmissione.month = 1 RETURN doc.documentoinstruction AS documento LIMIT 10"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Per i primi 3 clienti per ordinato, mostra il loro prodotto più acquistato per valore."}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE dr.tipoValore = 'Ordinato' AND dr.importo > 0 WITH c, sum(dr.importo) AS fatturatoTotale ORDER BY fatturatoTotale DESC LIMIT 3 MATCH (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE dr2.tipoValore = 'Ordinato' AND dr2.importo > 0 WITH c, a, sum(dr2.importo) AS valoreProdotto ORDER BY c.name, valoreProdotto DESC WITH c, collect({prodotto: a.descrizione, valore: valoreProdotto})[0] AS prodottoTop RETURN c.name AS cliente, prodottoTop.prodotto AS prodottoPiuAcquistato, prodottoTop.valore"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto COMPR.ASPERA NJ9232GK?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera nj9232gk' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'COMPR.ELECTROLUX ML90FB'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.electrolux ml90fb' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il margine di profitto del prodotto 'UNITA' CARENATA UTFACA D 313.1Y'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr1:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' carenata utfaca d 313.1y' AND dr1.tipoValore = 'Fatturato' AND dr1.importo > 0 WITH a, sum(dr1.importo) AS fatturato MATCH (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WITH a, fatturato, sum(dr2.importo) AS costo RETURN a.descrizione AS prodotto, fatturato, costo, (fatturato - costo) AS margine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il margine di profitto del prodotto 'COMPR ASPERA NE9213GK'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr1:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr aspera ne9213gk' AND dr1.tipoValore = 'Fatturato' AND dr1.importo > 0 WITH a, sum(dr1.importo) AS fatturato MATCH (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WITH a, fatturato, sum(dr2.importo) AS costo RETURN a.descrizione AS prodotto, fatturato, costo, (fatturato - costo) AS margine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il prodotto più venduto in generale (per valore)?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN a.descrizione AS prodotto, sum(dr.importo) AS valoreVenduto ORDER BY valoreVenduto DESC LIMIT 1"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto COMPRESSORE ELECTROLUX ML90FB?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'compressore electrolux ml90fb' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Calcola il rapporto tra costo totale e fatturato totale per il prodotto 'COMPRESSORE MP14FB'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compressore mp14fb' OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_acq:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WITH a, sum(dr_acq.importo) AS costoTotale OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_ven:RigaDocumento {tipoValore: 'Fatturato'})<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_RICEVUTO]-(:Cliente) WHERE dr_ven.importo > 0 WITH costoTotale, sum(dr_ven.importo) AS fatturatoTotale RETURN costoTotale, fatturatoTotale, (fatturatoTotale / costoTotale) AS rapporto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho speso per acquistare il prodotto COMPR.ASPERA T6213Z?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'compr.aspera t6213z' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il fatturato totale del cliente TCU TRADING LTD?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE toLower(trim(c.name)) = 'tcu trading ltd' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS fatturatoTotale"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Calcola il rapporto tra costo totale e fatturato totale per il prodotto 'COMPR.ASPERA NE6187Z'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera ne6187z' OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_acq:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WITH a, sum(dr_acq.importo) AS costoTotale OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_ven:RigaDocumento {tipoValore: 'Fatturato'})<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_RICEVUTO]-(:Cliente) WHERE dr_ven.importo > 0 WITH costoTotale, sum(dr_ven.importo) AS fatturatoTotale RETURN costoTotale, fatturatoTotale, (fatturatoTotale / costoTotale) AS rapporto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto PORTABILANCIA INOX?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'portabilancia inox' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il margine di profitto del prodotto 'unita' condensatrice uchg 33 a nek6210gk'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr1:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' condensatrice uchg 33 a nek6210gk' AND dr1.tipoValore = 'Fatturato' AND dr1.importo > 0 WITH a, sum(dr1.importo) AS fatturato MATCH (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WITH a, fatturato, sum(dr2.importo) AS costo RETURN a.descrizione AS prodotto, fatturato, costo, (fatturato - costo) AS margine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il margine di profitto del prodotto 'UNITA' COND.TEAV 2 J2212GK'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr1:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' cond.teav 2 j2212gk' AND dr1.tipoValore = 'Fatturato' AND dr1.importo > 0 WITH a, sum(dr1.importo) AS fatturato MATCH (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WITH a, fatturato, sum(dr2.importo) AS costo RETURN a.descrizione AS prodotto, fatturato, costo, (fatturato - costo) AS margine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho speso per acquistare il prodotto COMPR.ELECTROLUX GP12TB R134?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'compr.electrolux gp12tb r134' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto COMPRESSORE ELECTROLUX MX 18TB R404A?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compressore electrolux mx 18tb r404a' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto COMPR.ASPERA NEK 6213 GK?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera nek 6213 gk' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto UNITA' CONDENSATRICE TEAV NEK6165GK?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' condensatrice teav nek6165gk' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il fatturato totale del cliente GRUPPO CB SRL?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE toLower(trim(c.name)) = 'gruppo cb srl' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS fatturatoTotale"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il margine di profitto del prodotto 'COMPR.MANEUROP. MTZ40JH 4VE R404'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr1:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.maneurop. mtz40jh 4ve r404' AND dr1.tipoValore = 'Fatturato' AND dr1.importo > 0 WITH a, sum(dr1.importo) AS fatturato MATCH (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WITH a, fatturato, sum(dr2.importo) AS costo RETURN a.descrizione AS prodotto, fatturato, costo, (fatturato - costo) AS margine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto COMPR.ASPERA T6213Z?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera t6213z' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quali sono i 3 prodotti più venduti al cliente 'BARONE DI FERRANTE EZIO'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(c.name)) = 'barone di ferrante ezio' AND dr.tipoValore = 'Bollato' AND dr.importo > 0 RETURN a.descrizione AS prodotto, sum(dr.importo) AS totaleVenduto ORDER BY totaleVenduto DESC LIMIT 3"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Mostrami i 100 prodotti più popolari in termini di quantità venduta"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) RETURN a.descrizione AS prodotto, sum(dr.quantita) AS quantitaTotale ORDER BY quantitaTotale DESC LIMIT 100"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Mostrami i 3 mesi con il maggior numero di documenti di acquisto registrati."}, {"role": "assistant", "content": "MATCH (:Fornitore)-[:HA_EMESSO]->(doc:Documento) RETURN doc.dataEmissione.year AS anno, doc.dataEmissione.month AS mese, count(doc) AS numeroDocumenti ORDER BY numeroDocumenti DESC LIMIT 3"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Mostrami 10 documenti di tipo 'FVC' emessi a Gennaio 2025 al cliente 'COM-FOUR VERTRIEBS GMBH'"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:IS_TYPE]->(dt:DocType) WHERE toLower(trim(c.name)) = 'com-four vertriebs gmbh' AND dt.codice = 'FVC' AND doc.dataEmissione.year = 2025 AND doc.dataEmissione.month = 1 RETURN doc.documentoinstruction AS documento LIMIT 10"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quali sono i 3 prodotti più venduti al cliente 'SHENZHENSHIXIAOHUANDIANZISHAGWUYOUXIANGONGSI'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(c.name)) = 'shenzhenshixiaohuandianzishagwuyouxiangongsi' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN a.descrizione AS prodotto, sum(dr.importo) AS totaleVenduto ORDER BY totaleVenduto DESC LIMIT 3"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il margine di profitto del prodotto 'COMPR.ASPERA NJ9232E'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr1:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera nj9232e' AND dr1.tipoValore = 'Fatturato' AND dr1.importo > 0 WITH a, sum(dr1.importo) AS fatturato MATCH (f:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(dr2:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WITH a, fatturato, sum(dr2.importo) AS costo RETURN a.descrizione AS prodotto, fatturato, costo, (fatturato - costo) AS margine"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Calcola il rapporto tra costo totale e fatturato totale per il prodotto 'COMPR.ASPERA T6213Z'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera t6213z' OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_acq:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WITH a, sum(dr_acq.importo) AS costoTotale OPTIONAL MATCH (a)<-[:RIGUARDA_ARTICOLO]-(dr_ven:RigaDocumento {tipoValore: 'Fatturato'})<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_RICEVUTO]-(:Cliente) WHERE dr_ven.importo > 0 WITH costoTotale, sum(dr_ven.importo) AS fatturatoTotale RETURN costoTotale, fatturatoTotale, (fatturatoTotale / costoTotale) AS rapporto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto COMPR.ELECTROLUX ML90FB?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.electrolux ml90fb' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Mostrami i documenti di tipo 'FVC' emessi a gennaio 2025 per il cliente 'ZYXEL NETWORKS A/S'"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:IS_TYPE]->(dt:DocType) WHERE toLower(trim(c.name)) = 'zyxel networks a/s' AND dt.codice = 'FVC' AND doc.dataEmissione.year = 2025 AND doc.dataEmissione.month = 1 RETURN doc.documentoinstruction AS documento"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto SPORTELLI SCORREVOLI?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'sportelli scorrevoli' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho speso per acquistare il prodotto GAS FREON SOLSTICE N40 R448A?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'gas freon solstice n40 r448a' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho speso per acquistare il prodotto A 1 6Y COMPR.FRASCOLD?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'a 1 6y compr.frascold' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è l'importo medio per riga documento nelle fatture di vendita?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN avg(dr.importo) AS importoMedioRiga"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho guadagnato vendendo il prodotto DOSATORE ANTICALCARE?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'dosatore anticalcare' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto COMPR.ASPERA NE6170Z?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.aspera ne6170z' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto FABBRICATORE GHIACCIO S550 A?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'fabbricatore ghiaccio s550 a' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto UNITA' CARENATA UTFACA D 313.1Y?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'unita' carenata utfaca d 313.1y' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'UNITA' ERMETICA UE6187Z-02'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' ermetica ue6187z-02' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Per il cliente 'ACME SRL', confronta il totale ordinato e il totale fatturato."}, {"role": "assistant", "content": "MATCH (c:Cliente) WHERE toLower(trim(c.name)) = 'acme srl' OPTIONAL MATCH (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr_ord:RigaDocumento {tipoValore: 'Ordinato'}) WITH c, sum(dr_ord.importo) AS totaleOrdinato OPTIONAL MATCH (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr_fat:RigaDocumento {tipoValore: 'Fatturato'}) WHERE dr_fat.importo > 0 RETURN totaleOrdinato, sum(dr_fat.importo) AS totaleFatturato"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'UNITA' COND.TEAV 2 J2212GK'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' cond.teav 2 j2212gk' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto COMPRESSORE ASPERA NJ9238GK?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compressore aspera nj9238gk' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il fatturato totale del cliente AMAZON EU S.A.R.L., SUCCURSALE ITALIANA?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE toLower(trim(c.name)) = 'amazon eu s.a.r.l., succursale italiana' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS fatturatoTotale"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho speso per acquistare il prodotto GUARNIZIONE PER PORTA?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'guarnizione per porta' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quali fornitori ci forniscono prodotti venduti al cliente 'ANKER TECHNOLOGY (UK) LTD'?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(c.name)) = 'anker technology (uk) ltd' WITH collect(DISTINCT a) AS articoliVenduti MATCH (gf:GruppoFornitore)<-[:RAGGRUPPATO_SOTTO]-(:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) WHERE a IN articoliVenduti RETURN DISTINCT gf.ragioneSociale AS fornitore ORDER BY fornitore"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Calcola il valore medio di un documento per ciascun tipo (considerando solo il ordinato)."}, {"role": "assistant", "content": "MATCH (doc:Documento)-[:IS_TYPE]->(dt:DocType) MATCH (doc)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE dr.tipoValore = 'Ordinato' AND dr.importo > 0 WITH dt, doc, sum(dr.importo) AS valoreDocumento RETURN dt.codice AS tipoDocumento, avg(valoreDocumento) AS valoreMedio ORDER BY valoreMedio DESC"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Trova i fornitori che non ci hanno mai venduto prodotti della famiglia 'FRONTALE'"}, {"role": "assistant", "content": "MATCH (fam:Famiglia) WHERE toLower(trim(fam.nome)) = 'frontale' WITH fam MATCH (gf:GruppoFornitore) WHERE NOT (gf)<-[:RAGGRUPPATO_SOTTO]-(:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)-[:INCLUSA_IN]->(fam) RETURN gf.ragioneSociale AS fornitore"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Qual è il fatturato tra Gennaio 2024 e Marzo 2024?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(doc:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0 AND doc.dataEmissione >= date('2024-01-01') AND doc.dataEmissione <= date('2024-03-31') RETURN sum(dr.importo) AS fatturatoPeriodo"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto UNITA' CONDENSATRICE DORIN H300CC?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'unita' condensatrice dorin h300cc' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Chi sono i principali fornitori degli articoli venduti al nostro miglior cliente?"}, {"role": "assistant", "content": "MATCH (c:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento) WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0 WITH c, sum(dr.importo) AS fatturato ORDER BY fatturato DESC LIMIT 1 MATCH (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WITH collect(DISTINCT a) AS articoliTop MATCH (gf:GruppoFornitore)<-[:RAGGRUPPATO_SOTTO]-(:Fornitore)-[:HA_EMESSO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a_check:Articolo) WHERE a_check IN articoliTop RETURN gf.ragioneSociale as fornitore, sum(dr.importo) AS valoreAcquistato ORDER BY valoreAcquistato DESC"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto UNITA' COND.ERMET. TEAC NB6152GK?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'unita' cond.ermet. teac nb6152gk' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Elenca 5 clienti che non hanno mai acquistato il prodotto 'COMPR.ELECTROLUX ML60TB'"}, {"role": "assistant", "content": "MATCH (a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.electrolux ml60tb' WITH a MATCH (c:Cliente) WHERE NOT (c)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a) RETURN c.name AS cliente ORDER BY cliente LIMIT 5"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "Quanto ho speso per acquistare il prodotto COMPRESSORE ASPERA T6215Z?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'compressore aspera t6215z' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto ho acquistato il prodotto UNITA' COND. ERMET.TEAC 6165GK?"}, {"role": "assistant", "content": "MATCH (a:Articolo)<-[:RIGUARDA_ARTICOLO]-(dr:RigaDocumento)<-[:CONTIENE_RIGA]-(:Documento)<-[:HA_EMESSO]-(:Fornitore) WHERE toLower(trim(a.descrizione)) = 'unita' cond. ermet.teac 6165gk' RETURN sum(dr.importo) AS costoTotaleAcquisto"}]}
{"messages": [{"role": "system", "content": "Sei un esperto Cypher. Genera solo codice. Obbedisci rigorosamente alle REGOLE e usa solo lo SCHEMA fornito.\n\n--- REGOLE ---\n**DIRETTIVA PRINCIPALE: SEI UN GENERATORE CYPHER, NON SQL.**\n- **NON USARE SQL:** Mai usare `GROUP BY`, `OVER`, `PARTITION BY`, `rank()`, `HAVING`. Cypher aggrega implicitamente nel `RETURN`.\n- **Usa SOLO `MATCH` e `RETURN`** per sicurezza.\n\n---\n\n**REGOLE CRITICHE DI LOGICA E BUSINESS (OBBLIGATORIE):**\n1.  **Distinzione Cliente vs. Fornitore (Percorsi Obbligatori):** \n    * **VENDITE/FATTURATO/POPOLARITÀ:** Il percorso DEVE iniziare da `(:Cliente)-[:HA_RICEVUTO]->...`\n    * **COSTI/ACQUISTI:** Il percorso DEVE iniziare da `(:Fornitore)-[:HA_EMESSO]->...` (aggregando poi su `GruppoFornitore.ragioneSociale` se richiesto \"fornitore\").\n\n2.  **Mappatura `tipoValore` (Keyword -> Filtro Obbligatorio):** \n    * \"fatturato\", \"venduto\", \"sales\", \"revenue\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Fatturato' AND dr.importo > 0`\n    * \"ordinato\", \"ordini\", \"orders\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Ordinato'` (e `AND dr.importo > 0` se si parla di valore)\n    * \"bolle\", \"DDT\", \"delivery notes\" -> USA ESATTAMENTE: `WHERE dr.tipoValore = 'Bollato'` (o `'DDT'` se esiste) (e `AND dr.importo > 0` se si parla di valore)\n    * Se **NON** specificato -> **NON** filtrare per `dr.tipoValore`, ma usa `WHERE dr.importo > 0` se si parla di \"valore\" generico.\n\n3.  **Quantità vs. Valore:**\n    * Per numero/popolarità -> `sum(dr.quantita)`\n    * Per valore/importanza -> `sum(dr.importo)`\n\n---\n\n**REGOLE CRITICHE DI SINTASSI (OBBLIGATORIE):**\n\n4.  **Dichiarazione Variabili:** Ogni variabile in `WHERE`, `WITH`, `ORDER BY` o `RETURN` DEVE essere definita prima nel `MATCH` con un alias (es. `MATCH (c:Cliente)`). È un errore grave non farlo.\n\n5.  **Filtri Stringa:**\n    * **ID Esatti** (`dittaId`, `codice`, `accountnumber`): Usa match diretto `MATCH (n {prop: 'valore'})`.\n    * **Testo** (`name`, `descrizione`, `localita`): Usa SEMPRE `WHERE toLower(trim(var.prop)) = 'valore minuscolo'`.\n\n6.  **Apostrofi nelle Stringhe:** Per filtrare stringhe con apostrofo (es. `L'ABBONDANZA SRL`), DEVI usare il backslash: `WHERE toLower(trim(c.name)) = 'l\\'abbondanza srl'`.\n\n7.  **Date:** Usa le proprietà `.year`, `.month`, `.day` sulla proprietà `doc.dataEmissione`.\n\n8.  **Uso di `WITH` (Limitato):**\n    * **Priorità 1:** Usa un **singolo `MATCH`** per percorsi continui.\n    * **Priorità 2:** Usa `WITH` **SOLO** per:\n        * Passare risultati aggregati o liste a fasi successive (`WITH c, sum(dr.importo) AS totale ...`).\n        * Filtrare *dopo* un'aggregazione (`... WITH c, sum(dr.importo) AS totale WHERE totale > 100 ...`).\n    * **Dopo `WITH`:** Puoi usare solo variabili definite nel `WITH` stesso. Variabili del `MATCH` precedente *non* sono più disponibili.\n\n9.  **Query Negative (`WHERE NOT pattern`):** Usa questo pattern preciso per \"chi NON ha fatto X\":\n    * `MATCH (entita_da_escludere)` -> Trova l'entità specifica (es. il prodotto).\n    * `WITH entita_da_escludere` -> Passala avanti.\n    * `MATCH (entita_principale)` -> Trova le entità da cui partire (es. i clienti).\n    * `WHERE NOT (entita_principale)-[percorso_completo]->(entita_da_escludere)` -> Applica la negazione sul percorso.\n    * **NON** definire nuove variabili dentro `WHERE NOT`. **NON** usare `WHERE NOT entity IN list`.\n\n---\n\n**GLOSSARIO E PROPRIETÀ CHIAVE:**\n\n- `Ditta`: Identifica con `d.dittaId` (MAI `d.name`).\n- `Cliente`: Identifica e raggruppa con `c.name`.\n- `GruppoFornitore`: **Entità principale per \"fornitore\"**. Identifica e raggruppa con `gf.ragioneSociale`.\n- `Fornitore`: Ramo/sede, usa per percorsi ma aggrega su `GruppoFornitore`.\n- `Articolo`: Usa `a.descrizione`.\n- `Documento`: Usa `doc.documentoId` per ID, `doc.tipoOriginale` per filtri, `doc.dataEmissione` per date.\n- `RigaDocumento`: Usa `dr.tipoValore` per filtri (fatturato, ordinato, bollato), `dr.importo` e `dr.quantita`\n- `Famiglia`: Usa `fam.nome`.\n- `Sottofamiglia`: Usa `sf.nome`.\n- `DocType`: Usa `dt.codice` per filtri tecnici, `dt.nome` per output leggibile.\n- `Luogo`: Restituisci per `l.provincia` (sigla, es. 'PG'), altrimenti usa `l.localita` o `l.regione` (es. 'Perugia'). Se sigla non nota, usa `l.localita`.\n\n---\n\n**BUONE PRATICHE E FORMATTAZIONE OUTPUT:**\n\n10. **Liste Uniche:** Usa SEMPRE `DISTINCT` quando elenchi entità (`RETURN DISTINCT c.name`).\n11. **Classifiche \"Top N\":** Raggruppa per proprietà testuale, poi usa `RETURN ... ORDER BY metrica DESC LIMIT N`.\n12. **Ordinamento Default:** Se aggreghi (sum, count), ordina i risultati `DESC` per valore, a meno che non sia specificato \"minore\" o \"meno\". Per liste testuali, usa `ORDER BY proprieta ASC`.\n13. **Limite Default:** Se l'utente chiede una lista senza specificare quanti, aggiungi SEMPRE `LIMIT 10`.\n14. **Alias Aggregazioni:** Usa alias semplici: `sum()` -> `totale`, `count()` -> `conteggio`, `avg()` -> `media`.\n15. **Output Finale:** Restituisci **SOLO** la query Cypher valida, senza spiegazioni, commenti, ```cypher ``` o testo introduttivo/conclusivo.\n\n---\n\n**Schema del Grafo (UFFICIALE):**\n* Nodi: `(:Ditta)`, `(:Cliente)`, `(:GruppoFornitore)`, `(:Fornitore)`, `(:Articolo)`, `(:Documento)`, `(:RigaDocumento)`, `(:Luogo)`, `(:DocType)`, `(:Famiglia)`, `(:Sottofamiglia)`.\n* Relazioni:\n  * (:Fornitore)-[:RAGGRUPPATO_SOTTO]->(:GruppoFornitore)\n  * (:Fornitore)-[:APPARTIENE_A]->(:Ditta)\n  * (:Fornitore)-[:SI_TROVA_A]->(:Luogo)\n  * (:Fornitore)-[:HA_EMESSO]->(:Documento)\n  * (:Cliente)-[:APPARTIENE_A]->(:Ditta)\n  * (:Cliente)-[:HAS_ADDRESS]->(:Luogo)\n  * (:Cliente)-[:HA_RICEVUTO]->(:Documento)\n  * (:Articolo)-[:APPARTIENE_A]->(:Sottofamiglia)\n  * (:Sottofamiglia)-[:INCLUSA_IN]->(:Famiglia)\n  * (:Documento)-[:IS_TYPE]->(:DocType)\n  * (:Documento)-[:CONTIENE_RIGA]->(:RigaDocumento)\n  * (:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(:Articolo)\n\n--- SCHEMA DEL GRAFO ---\n(Schema dettagliato fornito a runtime. Nodi principali: Cliente, Articolo, Documento, Fornitore, Ditta, Famiglia, Luogo, GruppoFornitore, Sottofamiglia, RigaDocumento, DocType. Relazioni principali: RAGGRUPPATO_SOTTO, APPARTIENE_A, SI_TROVA_A, HA_RICEVUTO, CONTIENE_RIGA, RIGUARDA_ARTICOLO, HA_EMESSO, HAS_ADDRESS, IS_TYPE)"}, {"role": "user", "content": "A quanto l'ho venduto il prodotto COMPR.BITZER 4TC82Y40?"}, {"role": "assistant", "content": "MATCH (:Cliente)-[:HA_RICEVUTO]->(:Documento)-[:CONTIENE_RIGA]->(dr:RigaDocumento)-[:RIGUARDA_ARTICOLO]->(a:Articolo) WHERE toLower(trim(a.descrizione)) = 'compr.bitzer 4tc82y40' AND dr.tipoValore = 'Fatturato' AND dr.importo > 0 RETURN sum(dr.importo) AS totaleVenduto"}]}
